<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/Stuk/jszip#readme">jszip (v3.1.3)</a>
</h1>
<h4>Create, read and edit .zip files with Javascript http://stuartk.com/jszip</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip">module jszip</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.jszip">
            function <span class="apidocSignatureSpan"></span>jszip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.compressedObject">
            function <span class="apidocSignatureSpan">jszip.</span>compressedObject
            <span class="apidocSignatureSpan">(compressedSize, uncompressedSize, crc32, compression, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.crc32">
            function <span class="apidocSignatureSpan">jszip.</span>crc32
            <span class="apidocSignatureSpan">(input, crc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.external.Promise">
            function <span class="apidocSignatureSpan">jszip.</span>external.Promise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.load">
            function <span class="apidocSignatureSpan">jszip.</span>load
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.loadAsync">
            function <span class="apidocSignatureSpan">jszip.</span>loadAsync
            <span class="apidocSignatureSpan">(content, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.toString">
            function <span class="apidocSignatureSpan">jszip.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries">
            function <span class="apidocSignatureSpan">jszip.</span>zipEntries
            <span class="apidocSignatureSpan">(loadOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry">
            function <span class="apidocSignatureSpan">jszip.</span>zipEntry
            <span class="apidocSignatureSpan">(options, loadOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject">
            function <span class="apidocSignatureSpan">jszip.</span>zipObject
            <span class="apidocSignatureSpan">(name, data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>base64</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>compressedObject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>external</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>flate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>nodejsUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>support</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>utf8</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>zipEntries.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>zipEntry.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>zipObject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jszip.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.base64">module jszip.base64</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.base64.decode">
            function <span class="apidocSignatureSpan">jszip.base64.</span>decode
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.base64.encode">
            function <span class="apidocSignatureSpan">jszip.base64.</span>encode
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.compressedObject">module jszip.compressedObject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.compressedObject.compressedObject">
            function <span class="apidocSignatureSpan">jszip.</span>compressedObject
            <span class="apidocSignatureSpan">(compressedSize, uncompressedSize, crc32, compression, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.compressedObject.createWorkerFrom">
            function <span class="apidocSignatureSpan">jszip.compressedObject.</span>createWorkerFrom
            <span class="apidocSignatureSpan">(uncompressedWorker, compression, compressionOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.compressedObject.prototype">module jszip.compressedObject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.compressedObject.prototype.getCompressedWorker">
            function <span class="apidocSignatureSpan">jszip.compressedObject.prototype.</span>getCompressedWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.compressedObject.prototype.getContentWorker">
            function <span class="apidocSignatureSpan">jszip.compressedObject.prototype.</span>getContentWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.crc32">module jszip.crc32</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.crc32.crc32">
            function <span class="apidocSignatureSpan">jszip.</span>crc32
            <span class="apidocSignatureSpan">(input, crc)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.external">module jszip.external</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.external.Promise">
            function <span class="apidocSignatureSpan">jszip.external.</span>Promise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.external.Promise">module jszip.external.Promise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.external.Promise.Promise">
            function <span class="apidocSignatureSpan">jszip.external.</span>Promise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.flate">module jszip.flate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.flate.compressWorker">
            function <span class="apidocSignatureSpan">jszip.flate.</span>compressWorker
            <span class="apidocSignatureSpan">(compressionOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.flate.uncompressWorker">
            function <span class="apidocSignatureSpan">jszip.flate.</span>uncompressWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jszip.flate.</span>magic</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.load">module jszip.load</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.load.load">
            function <span class="apidocSignatureSpan">jszip.</span>load
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.loadAsync">module jszip.loadAsync</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.loadAsync.loadAsync">
            function <span class="apidocSignatureSpan">jszip.</span>loadAsync
            <span class="apidocSignatureSpan">(content, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.nodejsUtils">module jszip.nodejsUtils</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>isNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.nodejsUtils.isBuffer">
            function <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>isBuffer
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.nodejsUtils.isStream">
            function <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>isStream
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.nodejsUtils.newBuffer">
            function <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>newBuffer
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.toString">module jszip.toString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.toString.toString">
            function <span class="apidocSignatureSpan">jszip.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.utf8">module jszip.utf8</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utf8.Utf8DecodeWorker">
            function <span class="apidocSignatureSpan">jszip.utf8.</span>Utf8DecodeWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utf8.Utf8EncodeWorker">
            function <span class="apidocSignatureSpan">jszip.utf8.</span>Utf8EncodeWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utf8.utf8decode">
            function <span class="apidocSignatureSpan">jszip.utf8.</span>utf8decode
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utf8.utf8encode">
            function <span class="apidocSignatureSpan">jszip.utf8.</span>utf8encode
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.utils">module jszip.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.applyFromCharCode">
            function <span class="apidocSignatureSpan">jszip.utils.</span>applyFromCharCode
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.checkSupport">
            function <span class="apidocSignatureSpan">jszip.utils.</span>checkSupport
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.delay">
            function <span class="apidocSignatureSpan">jszip.utils.</span>delay
            <span class="apidocSignatureSpan">(callback, args, self)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.extend">
            function <span class="apidocSignatureSpan">jszip.utils.</span>extend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.getTypeOf">
            function <span class="apidocSignatureSpan">jszip.utils.</span>getTypeOf
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.inherits">
            function <span class="apidocSignatureSpan">jszip.utils.</span>inherits
            <span class="apidocSignatureSpan">(ctor, superCtor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.newBlob">
            function <span class="apidocSignatureSpan">jszip.utils.</span>newBlob
            <span class="apidocSignatureSpan">(parts, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.prepareContent">
            function <span class="apidocSignatureSpan">jszip.utils.</span>prepareContent
            <span class="apidocSignatureSpan">(name, inputData, isBinary, isOptimizedBinaryString, isBase64)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.pretty">
            function <span class="apidocSignatureSpan">jszip.utils.</span>pretty
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.transformTo">
            function <span class="apidocSignatureSpan">jszip.utils.</span>transformTo
            <span class="apidocSignatureSpan">(outputType, input)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jszip.utils.</span>MAX_VALUE_16BITS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jszip.utils.</span>MAX_VALUE_32BITS</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.zipEntries">module jszip.zipEntries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.zipEntries">
            function <span class="apidocSignatureSpan">jszip.</span>zipEntries
            <span class="apidocSignatureSpan">(loadOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.zipEntries.prototype">module jszip.zipEntries.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.checkSignature">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>checkSignature
            <span class="apidocSignatureSpan">(expectedSignature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.isSignature">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>isSignature
            <span class="apidocSignatureSpan">(askedIndex, expectedSignature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.load">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>load
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.prepareReader">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>prepareReader
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.readBlockEndOfCentral">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readBlockEndOfCentral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.readBlockZip64EndOfCentral">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readBlockZip64EndOfCentral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.readBlockZip64EndOfCentralLocator">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readBlockZip64EndOfCentralLocator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.readCentralDir">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readCentralDir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.readEndOfCentral">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readEndOfCentral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.readLocalFiles">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readLocalFiles
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.zipEntry">module jszip.zipEntry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.zipEntry">
            function <span class="apidocSignatureSpan">jszip.</span>zipEntry
            <span class="apidocSignatureSpan">(options, loadOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.zipEntry.prototype">module jszip.zipEntry.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.findExtraFieldUnicodeComment">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>findExtraFieldUnicodeComment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.findExtraFieldUnicodePath">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>findExtraFieldUnicodePath
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.handleUTF8">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>handleUTF8
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.isEncrypted">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>isEncrypted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.parseZIP64ExtraField">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>parseZIP64ExtraField
            <span class="apidocSignatureSpan">(reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.processAttributes">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>processAttributes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.readCentralPart">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>readCentralPart
            <span class="apidocSignatureSpan">(reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.readExtraFields">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>readExtraFields
            <span class="apidocSignatureSpan">(reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.readLocalPart">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>readLocalPart
            <span class="apidocSignatureSpan">(reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.useUTF8">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>useUTF8
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.zipObject">module jszip.zipObject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.zipObject">
            function <span class="apidocSignatureSpan">jszip.</span>zipObject
            <span class="apidocSignatureSpan">(name, data, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.zipObject.prototype">module jszip.zipObject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype._compressWorker">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>_compressWorker
            <span class="apidocSignatureSpan">(compression, compressionOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype._decompressWorker">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>_decompressWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.asArrayBuffer">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asArrayBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.asBinary">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asBinary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.asNodeBuffer">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asNodeBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.asText">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.asUint8Array">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asUint8Array
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.async">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>async
            <span class="apidocSignatureSpan">(type, onUpdate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.internalStream">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>internalStream
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.nodeStream">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>nodeStream
            <span class="apidocSignatureSpan">(type, onUpdate)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip" id="apidoc.module.jszip">module jszip</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.jszip" id="apidoc.element.jszip.jszip">
        function <span class="apidocSignatureSpan"></span>jszip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSZip() {
    // if this constructor isÂ&nbsp;used withoutÂ&nbsp;`new`, itÂ&nbsp;adds `new` beforeÂ&nbsp;itself:
    if(!(this instanceof JSZip)) {
        return new JSZip();
    }

    if(arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }

    // object containing the files :
    // {
    //   "folder/" : {...},
    //   "folder/data.txt" : {...}
    // }
    this.files = {};

    this.comment = null;

    // Where we are in the hierarchy
    this.root = "";
    this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
            if (typeof this[i] !== "function") {
                newObj[i] = this[i];
            }
        }
        return newObj;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.compressedObject" id="apidoc.element.jszip.compressedObject">
        function <span class="apidocSignatureSpan">jszip.</span>compressedObject
        <span class="apidocSignatureSpan">(compressedSize, uncompressedSize, crc32, compression, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.crc32" id="apidoc.element.jszip.crc32">
        function <span class="apidocSignatureSpan">jszip.</span>crc32
        <span class="apidocSignatureSpan">(input, crc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
        return 0;
    }

    var isArray = utils.getTypeOf(input) !== "string";

    if(isArray) {
        return crc32(crc|0, input, input.length, 0);
    } else {
        return crc32str(crc|0, input, input.length, 0);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.external.Promise" id="apidoc.element.jszip.external.Promise">
        function <span class="apidocSignatureSpan">jszip.</span>external.Promise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.load" id="apidoc.element.jszip.load">
        function <span class="apidocSignatureSpan">jszip.</span>load
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode &amp;&amp; nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
    .then(function(data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i &lt; files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i &lt; files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment : input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions : input.unixPermissions,
                dosPermissions : input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (nodejsUtils.isNode &amp;&amp; nodejsUtils.isStream(data)) {
    return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
}

return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
.then(function(data) {
    var zipEntries = new ZipEntries(options);
    zipEntries.<span class="apidocCodeKeywordSpan">load</span>(data);
    return zipEntries;
}).then(function checkCRC32(zipEntries) {
    var promises = [external.Promise.resolve(zipEntries)];
    var files = zipEntries.files;
    if (options.checkCRC32) {
        for (var i = 0; i &lt; files.length; i++) {
            promises.push(checkEntryCRC32(files[i]));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.loadAsync" id="apidoc.element.jszip.loadAsync">
        function <span class="apidocSignatureSpan">jszip.</span>loadAsync
        <span class="apidocSignatureSpan">(content, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.toString" id="apidoc.element.jszip.toString">
        function <span class="apidocSignatureSpan">jszip.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).<span class="apidocCodeKeywordSpan">toString</span>("utf-8"
;);
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries" id="apidoc.element.jszip.zipEntries">
        function <span class="apidocSignatureSpan">jszip.</span>zipEntries
        <span class="apidocSignatureSpan">(loadOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry" id="apidoc.element.jszip.zipEntry">
        function <span class="apidocSignatureSpan">jszip.</span>zipEntry
        <span class="apidocSignatureSpan">(options, loadOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject" id="apidoc.element.jszip.zipObject">
        function <span class="apidocSignatureSpan">jszip.</span>zipObject
        <span class="apidocSignatureSpan">(name, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zipObject = function (name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression : options.compression,
        compressionOptions : options.compressionOptions
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.base64" id="apidoc.module.jszip.base64">module jszip.base64</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.base64.decode" id="apidoc.element.jszip.base64.decode">
        function <span class="apidocSignatureSpan">jszip.base64.</span>decode
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;

    var dataUrlPrefix = "data:";

    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        // This is a common error: people give a data url
        // (data:image/png;base64,iVBOR...) with a {base64: true} and
        // wonders why things don't work.
        // We can detect that the string input looks like a data url but we
        // *can't* be sure it is one: removing everything up to the comma would
        // be too dangerous.
        throw new Error("Invalid base64 input, it looks like a data url.");
    }

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    var totalLength = input.length * 3 / 4;
    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (totalLength % 1 !== 0) {
        // totalLength is not an integer, the length does not match a valid
        // base64 content. That can happen if:
        // - the input is not a base64 content
        // - the input is *almost* a base64 content, with a extra chars at the
        //   beginning or at the end
        // - the input uses a base64 variant (base64url for example)
        throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
        output = new Uint8Array(totalLength|0);
    } else {
        output = new Array(totalLength|0);
    }

    while (i &lt; input.length) {

        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4);
        chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2);
        chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4;

        output[resultIndex++] = chr1;

        if (enc3 !== 64) {
            output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
            output[resultIndex++] = chr3;
        }

    }

    return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    );
}
// special case : it's way easier to work with Uint8Array than with ArrayBuffer
if (dataType === "arraybuffer") {
    data = exports.transformTo("uint8array", data);
} else if (dataType === "string") {
    if (isBase64) {
        data = base64.<span class="apidocCodeKeywordSpan">decode</span>(data);
    }
    else if (isBinary) {
        // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
        if (isOptimizedBinaryString !== true) {
            // this is a string, not in a base64 format.
            // Be sure that this is a correct "binary string"
            data = string2binary(data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.base64.encode" id="apidoc.element.jszip.base64.encode">
        function <span class="apidocSignatureSpan">jszip.base64.</span>encode
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;

    var isArray = utils.getTypeOf(input) !== "string";
    while (i &lt; input.length) {
        remainingBytes = len - i;

        if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i &lt; len ? input.charCodeAt(i++) : 0;
            chr3 = i &lt; len ? input.charCodeAt(i++) : 0;
        } else {
            chr1 = input[i++];
            chr2 = i &lt; len ? input[i++] : 0;
            chr3 = i &lt; len ? input[i++] : 0;
        }

        enc1 = chr1 &gt;&gt; 2;
        enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4);
        enc3 = remainingBytes &gt; 1 ? (((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6)) : 64;
        enc4 = remainingBytes &gt; 2 ? (chr3 &amp; 63) : 64;

        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));

    }

    return output.join("");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.compressedObject" id="apidoc.module.jszip.compressedObject">module jszip.compressedObject</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.compressedObject.compressedObject" id="apidoc.element.jszip.compressedObject.compressedObject">
        function <span class="apidocSignatureSpan">jszip.</span>compressedObject
        <span class="apidocSignatureSpan">(compressedSize, uncompressedSize, crc32, compression, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.compressedObject.createWorkerFrom" id="apidoc.element.jszip.compressedObject.createWorkerFrom">
        function <span class="apidocSignatureSpan">jszip.compressedObject.</span>createWorkerFrom
        <span class="apidocSignatureSpan">(uncompressedWorker, compression, compressionOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker
    .pipe(new Crc32Probe())
    .pipe(new DataLengthProbe("uncompressedSize"))
    .pipe(compression.compressWorker(compressionOptions))
    .pipe(new DataLengthProbe("compressedSize"))
    .withStreamInfo("compression", compression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ) {
        return this._data.getCompressedWorker();
    } else {
        var result = this._decompressWorker();
        if(!this._dataBinary) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
        }
        return CompressedObject.<span class="apidocCodeKeywordSpan">createWorkerFrom</span>(result, compression, compressionOptions
);
    }
},
/**
 * Return a worker for the decompressed content.
 * @private
 * @return Worker the worker.
 */
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.compressedObject.prototype" id="apidoc.module.jszip.compressedObject.prototype">module jszip.compressedObject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.compressedObject.prototype.getCompressedWorker" id="apidoc.element.jszip.compressedObject.prototype.getCompressedWorker">
        function <span class="apidocSignatureSpan">jszip.compressedObject.prototype.</span>getCompressedWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCompressedWorker = function () {
    return new DataWorker(external.Promise.resolve(this.compressedContent))
    .withStreamInfo("compressedSize", this.compressedSize)
    .withStreamInfo("uncompressedSize", this.uncompressedSize)
    .withStreamInfo("crc32", this.crc32)
    .withStreamInfo("compression", this.compression)
    ;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return Worker the worker.
 */
_compressWorker: function (compression, compressionOptions) {
    if (
        this._data instanceof CompressedObject &amp;&amp;
        this._data.compression.magic === compression.magic
    ) {
        return this._data.<span class="apidocCodeKeywordSpan">getCompressedWorker</span>();
    } else {
        var result = this._decompressWorker();
        if(!this._dataBinary) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
        }
        return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.compressedObject.prototype.getContentWorker" id="apidoc.element.jszip.compressedObject.prototype.getContentWorker">
        function <span class="apidocSignatureSpan">jszip.compressedObject.prototype.</span>getContentWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContentWorker = function () {
    var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
    .pipe(this.compression.uncompressWorker())
    .pipe(new DataLengthProbe("data_length"));

    var that = this;
    worker.on("end", function () {
        if(this.streamInfo['data_length'] !== that.uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
        }
    });
    return worker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
return new external.Promise(function (resolve, reject) {
    var worker = zipEntry.decompressed.<span class="apidocCodeKeywordSpan">getContentWorker</span>().pipe(new Crc32Probe());
    worker.on("error", function (e) {
        reject(e);
    })
    .on("end", function () {
        if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
            reject(new Error("Corrupted zip : CRC32 mismatch"));
        } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.crc32" id="apidoc.module.jszip.crc32">module jszip.crc32</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.crc32.crc32" id="apidoc.element.jszip.crc32.crc32">
        function <span class="apidocSignatureSpan">jszip.</span>crc32
        <span class="apidocSignatureSpan">(input, crc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
        return 0;
    }

    var isArray = utils.getTypeOf(input) !== "string";

    if(isArray) {
        return crc32(crc|0, input, input.length, 0);
    } else {
        return crc32str(crc|0, input, input.length, 0);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.external" id="apidoc.module.jszip.external">module jszip.external</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.external.Promise" id="apidoc.element.jszip.external.Promise">
        function <span class="apidocSignatureSpan">jszip.external.</span>Promise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
return new external.<span class="apidocCodeKeywordSpan">Promise</span>(function (resolve, reject) {
    var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
    worker.on("error", function (e) {
        reject(e);
    })
    .on("end", function () {
        if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
            reject(new Error("Corrupted zip : CRC32 mismatch"));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.external.Promise" id="apidoc.module.jszip.external.Promise">module jszip.external.Promise</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.external.Promise.Promise" id="apidoc.element.jszip.external.Promise.Promise">
        function <span class="apidocSignatureSpan">jszip.external.</span>Promise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
return new external.<span class="apidocCodeKeywordSpan">Promise</span>(function (resolve, reject) {
    var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
    worker.on("error", function (e) {
        reject(e);
    })
    .on("end", function () {
        if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
            reject(new Error("Corrupted zip : CRC32 mismatch"));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.flate" id="apidoc.module.jszip.flate">module jszip.flate</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.flate.compressWorker" id="apidoc.element.jszip.flate.compressWorker">
        function <span class="apidocSignatureSpan">jszip.flate.</span>compressWorker
        <span class="apidocSignatureSpan">(compressionOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */
CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker
    .pipe(new Crc32Probe())
    .pipe(new DataLengthProbe("uncompressedSize"))
    .pipe(compression.<span class="apidocCodeKeywordSpan">compressWorker</span>(compressionOptions))
    .pipe(new DataLengthProbe("compressedSize"))
    .withStreamInfo("compression", compression);
};

module.exports = CompressedObject;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.flate.uncompressWorker" id="apidoc.element.jszip.flate.uncompressWorker">
        function <span class="apidocSignatureSpan">jszip.flate.</span>uncompressWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker : function () {
var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
.pipe(this.compression.<span class="apidocCodeKeywordSpan">uncompressWorker</span>())
.pipe(new DataLengthProbe("data_length"));

var that = this;
worker.on("end", function () {
    if(this.streamInfo['data_length'] !== that.uncompressedSize) {
        throw new Error("Bug : uncompressed data size mismatch");
    }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.load" id="apidoc.module.jszip.load">module jszip.load</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.load.load" id="apidoc.element.jszip.load.load">
        function <span class="apidocSignatureSpan">jszip.</span>load
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode &amp;&amp; nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
    .then(function(data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i &lt; files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i &lt; files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment : input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions : input.unixPermissions,
                dosPermissions : input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (nodejsUtils.isNode &amp;&amp; nodejsUtils.isStream(data)) {
    return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
}

return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
.then(function(data) {
    var zipEntries = new ZipEntries(options);
    zipEntries.<span class="apidocCodeKeywordSpan">load</span>(data);
    return zipEntries;
}).then(function checkCRC32(zipEntries) {
    var promises = [external.Promise.resolve(zipEntries)];
    var files = zipEntries.files;
    if (options.checkCRC32) {
        for (var i = 0; i &lt; files.length; i++) {
            promises.push(checkEntryCRC32(files[i]));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.loadAsync" id="apidoc.module.jszip.loadAsync">module jszip.loadAsync</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.loadAsync.loadAsync" id="apidoc.element.jszip.loadAsync.loadAsync">
        function <span class="apidocSignatureSpan">jszip.</span>loadAsync
        <span class="apidocSignatureSpan">(content, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.nodejsUtils" id="apidoc.module.jszip.nodejsUtils">module jszip.nodejsUtils</a></h1>




    <h2>
        <a href="#apidoc.element.jszip.nodejsUtils.isBuffer" id="apidoc.element.jszip.nodejsUtils.isBuffer">
        function <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>isBuffer
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBuffer = function (b){
    return Buffer.isBuffer(b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},
/**
 * Find out if an object is a Buffer.
 * @param {Object} b the object to test.
 * @return {Boolean} true if the object is a Buffer, false otherwise.
 */
isBuffer : function(b){
    return Buffer.<span class="apidocCodeKeywordSpan">isBuffer</span>(b);
},

isStream : function (obj) {
    return obj &amp;&amp;
        typeof obj.on === "function" &amp;&amp;
        typeof obj.pause === "function" &amp;&amp;
        typeof obj.resume === "function";
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.nodejsUtils.isStream" id="apidoc.element.jszip.nodejsUtils.isStream">
        function <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>isStream
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStream = function (obj) {
    return obj &amp;&amp;
        typeof obj.on === "function" &amp;&amp;
        typeof obj.pause === "function" &amp;&amp;
        typeof obj.resume === "function";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    base64: false,
    checkCRC32: false,
    optimizedBinaryString: false,
    createFolders: false,
    decodeFileName: utf8.utf8decode
});

if (nodejsUtils.isNode &amp;&amp; nodejsUtils.<span class="apidocCodeKeywordSpan">isStream</span>(data)) {
    return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
}

return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
.then(function(data) {
    var zipEntries = new ZipEntries(options);
    zipEntries.load(data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.nodejsUtils.newBuffer" id="apidoc.element.jszip.nodejsUtils.newBuffer">
        function <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>newBuffer
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newBuffer = function (data, encoding){
    return new Buffer(data, encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.<span class="apidocCodeKeywordSpan">newBuffer</span>(str, "utf-8");
    }

    return string2buf(str);
};


/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.toString" id="apidoc.module.jszip.toString">module jszip.toString</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.toString.toString" id="apidoc.element.jszip.toString.toString">
        function <span class="apidocSignatureSpan">jszip.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).<span class="apidocCodeKeywordSpan">toString</span>("utf-8"
;);
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.utf8" id="apidoc.module.jszip.utf8">module jszip.utf8</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.utf8.Utf8DecodeWorker" id="apidoc.element.jszip.utf8.Utf8DecodeWorker">
        function <span class="apidocSignatureSpan">jszip.utf8.</span>Utf8DecodeWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    // the last bytes if a chunk didn't end with a complete codepoint.
    this.leftOver = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var isUnicodeString = !this._dataBinary;

    if (isUnicodeString &amp;&amp; !askUnicodeString) {
        result = result.pipe(new utf8.Utf8EncodeWorker());
    }
    if (!isUnicodeString &amp;&amp; askUnicodeString) {
        result = result.pipe(new utf8.<span class="apidocCodeKeywordSpan">Utf8DecodeWorker</span>());
    }

    return new StreamHelper(result, outputType, "");
},

/**
 * Prepare the content in the asked type.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utf8.Utf8EncodeWorker" id="apidoc.element.jszip.utf8.Utf8EncodeWorker">
        function <span class="apidocSignatureSpan">jszip.utf8.</span>Utf8EncodeWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        outputType = "string";
    }
    var result = this._decompressWorker();

    var isUnicodeString = !this._dataBinary;

    if (isUnicodeString &amp;&amp; !askUnicodeString) {
        result = result.pipe(new utf8.<span class="apidocCodeKeywordSpan">Utf8EncodeWorker</span>());
    }
    if (!isUnicodeString &amp;&amp; askUnicodeString) {
        result = result.pipe(new utf8.Utf8DecodeWorker());
    }

    return new StreamHelper(result, outputType, "");
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utf8.utf8decode" id="apidoc.element.jszip.utf8.utf8decode">
        function <span class="apidocSignatureSpan">jszip.utf8.</span>utf8decode
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       } else {
           usableData = data.slice(0, nextBoundary);
           this.leftOver = data.slice(nextBoundary, data.length);
       }
   }

   this.push({
       data : exports.<span class="apidocCodeKeywordSpan">utf8decode</span>(usableData),
       meta : chunk.meta
   });
};

/**
* @see GenericWorker.flush
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utf8.utf8encode" id="apidoc.element.jszip.utf8.utf8encode">
        function <span class="apidocSignatureSpan">jszip.utf8.</span>utf8encode
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.newBuffer(str, "utf-8");
    }

    return string2buf(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
utils.inherits(Utf8EncodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8EncodeWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : exports.<span class="apidocCodeKeywordSpan">utf8encode</span>(chunk.data),
        meta : chunk.meta
    });
};
exports.Utf8EncodeWorker = Utf8EncodeWorker;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.utils" id="apidoc.module.jszip.utils">module jszip.utils</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.utils.applyFromCharCode" id="apidoc.element.jszip.utils.applyFromCharCode">
        function <span class="apidocSignatureSpan">jszip.utils.</span>applyFromCharCode
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayLikeToString(array) {
    // Performances notes :
    // --------------------
    // String.fromCharCode.apply(null, array) is the fastest, see
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
    // but the stack is limited (and we can get huge arrays !).
    //
    // result += String.fromCharCode(array[i]); generate too many strings !
    //
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
    // TODO : we now have workers that split the work. Do we still need that ?
    var chunk = 65536,
        type = exports.getTypeOf(array),
        canUseApply = true;
    if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }

    if (canUseApply) {
        while (chunk &gt; 1) {
            try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
                chunk = Math.floor(chunk / 2);
            }
        }
    }

    // no apply or chunk error : slow and painful algorithm
    // default browser on android 4.*
    return arrayToStringHelper.stringifyByChar(array);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            utf16buf = utf16buf.subarray(0, out);
        } else {
            utf16buf.length = out;
        }
    }

    // return String.fromCharCode.apply(null, utf16buf);
    return utils.<span class="apidocCodeKeywordSpan">applyFromCharCode</span>(utf16buf);
};


// That's all for the pako functions.


/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.checkSupport" id="apidoc.element.jszip.utils.checkSupport">
        function <span class="apidocSignatureSpan">jszip.utils.</span>checkSupport
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkSupport = function (type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
        throw new Error(type + " is not supported by this platform");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Array[String|ArrayBuffer]} parts the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */
exports.newBlob = function(parts, type) {
exports.<span class="apidocCodeKeywordSpan">checkSupport</span>("blob");

try {
    // Blob constructor
    return new Blob(parts, {
        type: type
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.delay" id="apidoc.element.jszip.utils.delay">
        function <span class="apidocSignatureSpan">jszip.utils.</span>delay
        <span class="apidocSignatureSpan">(callback, args, self)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delay = function (callback, args, self) {
    setImmediate(function () {
        callback.apply(self || null, args || []);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.extend" id="apidoc.element.jszip.utils.extend">
        function <span class="apidocSignatureSpan">jszip.utils.</span>extend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function () {
    var result = {}, i, attr;
    for (i = 0; i &lt; arguments.length; i++) { // arguments is not enumerable in some browsers
        for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) &amp;&amp; typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
            }
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    })
    .resume();
});
}

module.exports = function(data, options) {
var zip = this;
options = utils.<span class="apidocCodeKeywordSpan">extend</span>(options || {}, {
    base64: false,
    checkCRC32: false,
    optimizedBinaryString: false,
    createFolders: false,
    decodeFileName: utf8.utf8decode
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.getTypeOf" id="apidoc.element.jszip.utils.getTypeOf">
        function <span class="apidocSignatureSpan">jszip.utils.</span>getTypeOf
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTypeOf = function (input) {
    if (typeof input === "string") {
        return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
    }
    if (support.nodebuffer &amp;&amp; nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
    }
    if (support.uint8array &amp;&amp; input instanceof Uint8Array) {
        return "uint8array";
    }
    if (support.arraybuffer &amp;&amp; input instanceof ArrayBuffer) {
        return "arraybuffer";
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// public method for encoding
exports.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;

    var isArray = utils.<span class="apidocCodeKeywordSpan">getTypeOf</span>(input) !== "string";
    while (i &lt; input.length) {
remainingBytes = len - i;

if (!isArray) {
    chr1 = input.charCodeAt(i++);
    chr2 = i &lt; len ? input.charCodeAt(i++) : 0;
    chr3 = i &lt; len ? input.charCodeAt(i++) : 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.inherits" id="apidoc.element.jszip.utils.inherits">
        function <span class="apidocSignatureSpan">jszip.utils.</span>inherits
        <span class="apidocSignatureSpan">(ctor, superCtor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherits = function (ctor, superCtor) {
    var Obj = function() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self.push({
        data : data,
        meta : self.meta
    });
};
}

utils.<span class="apidocCodeKeywordSpan">inherits</span>(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
this.meta = chunk.meta;
this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.newBlob" id="apidoc.element.jszip.utils.newBlob">
        function <span class="apidocSignatureSpan">jszip.utils.</span>newBlob
        <span class="apidocSignatureSpan">(parts, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newBlob = function (parts, type) {
    exports.checkSupport("blob");

    try {
        // Blob constructor
        return new Blob(parts, {
            type: type
        });
    }
    catch (e) {

        try {
            // deprecated, browser only, old way
            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var builder = new Builder();
            for (var i = 0; i &lt; parts.length; i++) {
                builder.append(parts[i]);
            }
            return builder.getBlob(type);
        }
        catch (e) {

            // well, fuck ?!
            throw new Error("Bug : can't construct the Blob.");
        }
    }


}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.prepareContent" id="apidoc.element.jszip.utils.prepareContent">
        function <span class="apidocSignatureSpan">jszip.utils.</span>prepareContent
        <span class="apidocSignatureSpan">(name, inputData, isBinary, isOptimizedBinaryString, isBase64)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

    // if inputData is already a promise, this flatten it.
    var promise = external.Promise.resolve(inputData).then(function(data) {


        var isBlob = support.blob &amp;&amp; (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString
.call(data)) !== -1);

        if (isBlob &amp;&amp; typeof FileReader !== "undefined") {
            return new external.Promise(function (resolve, reject) {
                var reader = new FileReader();

                reader.onload = function(e) {
                    resolve(e.target.result);
                };
                reader.onerror = function(e) {
                    reject(e.target.error);
                };
                reader.readAsArrayBuffer(data);
            });
        } else {
            return data;
        }
    });

    return promise.then(function(data) {
        var dataType = exports.getTypeOf(data);

        if (!dataType) {
            return external.Promise.reject(
                new Error("The data of '" + name + "' is in an unsupported format !")
            );
        }
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
        if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
            if (isBase64) {
                data = base64.decode(data);
            }
            else if (isBinary) {
                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                }
            }
        }
        return data;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    decodeFileName: utf8.utf8decode
});

if (nodejsUtils.isNode &amp;&amp; nodejsUtils.isStream(data)) {
    return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
}

return utils.<span class="apidocCodeKeywordSpan">prepareContent</span>("the loaded zip file", data, true, options.optimizedBinaryString
, options.base64)
.then(function(data) {
    var zipEntries = new ZipEntries(options);
    zipEntries.load(data);
    return zipEntries;
}).then(function checkCRC32(zipEntries) {
    var promises = [external.Promise.resolve(zipEntries)];
    var files = zipEntries.files;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.pretty" id="apidoc.element.jszip.utils.pretty">
        function <span class="apidocSignatureSpan">jszip.utils.</span>pretty
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pretty = function (str) {
    var res = '',
        code, i;
    for (i = 0; i &lt; (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code &lt; 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} expectedSignature the expected signature.
 * @throws {Error} if it is an other signature.
 */
checkSignature: function(expectedSignature) {
    if (!this.reader.readAndCheckSignature(expectedSignature)) {
        this.reader.index -= 4;
        var signature = this.reader.readString(4);
        throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.<span class="apidocCodeKeywordSpan
">pretty</span>(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
    }
},
/**
 * Check if the given signature is at the given index.
 * @param {number} askedIndex the index to check.
 * @param {string} expectedSignature the signature to expect.
 * @return {boolean} true if the signature is here, false otherwise.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.transformTo" id="apidoc.element.jszip.utils.transformTo">
        function <span class="apidocSignatureSpan">jszip.utils.</span>transformTo
        <span class="apidocSignatureSpan">(outputType, input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transformTo = function (outputType, input) {
    if (!input) {
        // undefined, null, etc
        // an empty string won't harm.
        input = "";
    }
    if (!outputType) {
        return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
utils.inherits(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
this.meta = chunk.meta;
this._pako.push(utils.<span class="apidocCodeKeywordSpan">transformTo</span>(ARRAY_TYPE, chunk.data), false);
};

/**
 * @see GenericWorker.flush
 */
FlateWorker.prototype.flush = function () {
GenericWorker.prototype.flush.call(this);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.zipEntries" id="apidoc.module.jszip.zipEntries">module jszip.zipEntries</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.zipEntries.zipEntries" id="apidoc.element.jszip.zipEntries.zipEntries">
        function <span class="apidocSignatureSpan">jszip.</span>zipEntries
        <span class="apidocSignatureSpan">(loadOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.zipEntries.prototype" id="apidoc.module.jszip.zipEntries.prototype">module jszip.zipEntries.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.checkSignature" id="apidoc.element.jszip.zipEntries.prototype.checkSignature">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>checkSignature
        <span class="apidocSignatureSpan">(expectedSignature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkSignature = function (expectedSignature) {
    if (!this.reader.readAndCheckSignature(expectedSignature)) {
        this.reader.index -= 4;
        var signature = this.reader.readString(4);
        throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty
(expectedSignature) + ")");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Read the local files, based on the offset read in the central part.
 */
readLocalFiles: function() {
    var i, file;
    for (i = 0; i &lt; this.files.length; i++) {
        file = this.files[i];
        this.reader.setIndex(file.localHeaderOffset);
        this.<span class="apidocCodeKeywordSpan">checkSignature</span>(sig.LOCAL_FILE_HEADER);
        file.readLocalPart(this.reader);
        file.handleUTF8();
        file.processAttributes();
    }
},
/**
 * Read the central directory.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.isSignature" id="apidoc.element.jszip.zipEntries.prototype.isSignature">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>isSignature
        <span class="apidocSignatureSpan">(askedIndex, expectedSignature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSignature = function (askedIndex, expectedSignature) {
    var currentIndex = this.reader.index;
    this.reader.setIndex(askedIndex);
    var signature = this.reader.readString(4);
    var result = signature === expectedSignature;
    this.reader.setIndex(currentIndex);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset &lt; 0) {
// Check if the content is a truncated zip or complete garbage.
// A "LOCAL_FILE_HEADER" is not required at the beginning (auto
// extractible zip for example) but it can give a good hint.
// If an ajax request was used without responseType, we will also
// get unreadable data.
var isGarbage = !this.<span class="apidocCodeKeywordSpan">isSignature</span>(0, sig.LOCAL_FILE_HEADER);

if (isGarbage) {
    throw new Error("Can't find end of central directory : is this a zip file ? " +
                    "If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html");
} else {
    throw new Error("Corrupted zip : can't find end of central directory");
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.load" id="apidoc.element.jszip.zipEntries.prototype.load">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>load
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (data) {
    this.prepareReader(data);
    this.readEndOfCentral();
    this.readCentralDir();
    this.readLocalFiles();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (nodejsUtils.isNode &amp;&amp; nodejsUtils.isStream(data)) {
    return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
}

return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
.then(function(data) {
    var zipEntries = new ZipEntries(options);
    zipEntries.<span class="apidocCodeKeywordSpan">load</span>(data);
    return zipEntries;
}).then(function checkCRC32(zipEntries) {
    var promises = [external.Promise.resolve(zipEntries)];
    var files = zipEntries.files;
    if (options.checkCRC32) {
        for (var i = 0; i &lt; files.length; i++) {
            promises.push(checkEntryCRC32(files[i]));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.prepareReader" id="apidoc.element.jszip.zipEntries.prototype.prepareReader">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>prepareReader
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareReader = function (data) {
    this.reader = readerFor(data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.reader = readerFor(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.<span class="apidocCodeKeywordSpan">prepareReader</span>(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.readBlockEndOfCentral" id="apidoc.element.jszip.zipEntries.prototype.readBlockEndOfCentral">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readBlockEndOfCentral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBlockEndOfCentral = function () {
    this.diskNumber = this.reader.readInt(2);
    this.diskWithCentralDirStart = this.reader.readInt(2);
    this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
    this.centralDirRecords = this.reader.readInt(2);
    this.centralDirSize = this.reader.readInt(4);
    this.centralDirOffset = this.reader.readInt(4);

    this.zipCommentLength = this.reader.readInt(2);
    // warning : the encoding depends of the system locale
    // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
    // On a windows machine, this field is encoded with the localized windows code page.
    var zipComment = this.reader.readData(this.zipCommentLength);
    var decodeParamType = support.uint8array ? "uint8array" : "array";
    // To get consistent behavior with the generation part, we will assume that
    // this is utf8 encoded unless specified otherwise.
    var decodeContent = utils.transformTo(decodeParamType, zipComment);
    this.zipComment = this.loadOptions.decodeFileName(decodeContent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        throw new Error("Corrupted zip : can't find end of central directory");
    }

}
this.reader.setIndex(offset);
var endOfCentralDirOffset = offset;
this.checkSignature(sig.CENTRAL_DIRECTORY_END);
this.<span class="apidocCodeKeywordSpan">readBlockEndOfCentral</span>();


/* extract from the zip spec :
    4)  If one of the fields in the end of central directory
        record is too small to hold required data, the field
        should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
        ZIP64 format record should be created.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.readBlockZip64EndOfCentral" id="apidoc.element.jszip.zipEntries.prototype.readBlockZip64EndOfCentral">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readBlockZip64EndOfCentral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBlockZip64EndOfCentral = function () {
    this.zip64EndOfCentralSize = this.reader.readInt(8);
    this.reader.skip(4);
    // this.versionMadeBy = this.reader.readString(2);
    // this.versionNeeded = this.reader.readInt(2);
    this.diskNumber = this.reader.readInt(4);
    this.diskWithCentralDirStart = this.reader.readInt(4);
    this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
    this.centralDirRecords = this.reader.readInt(8);
    this.centralDirSize = this.reader.readInt(8);
    this.centralDirOffset = this.reader.readInt(8);

    this.zip64ExtensibleData = {};
    var extraDataSize = this.zip64EndOfCentralSize - 44,
        index = 0,
        extraFieldId,
        extraFieldLength,
        extraFieldValue;
    while (index &lt; extraDataSize) {
        extraFieldId = this.reader.readInt(2);
        extraFieldLength = this.reader.readInt(4);
        extraFieldValue = this.reader.readData(extraFieldLength);
        this.zip64ExtensibleData[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
        if (this.relativeOffsetEndOfZip64CentralDir &lt; 0) {
            throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
        }
    }
    this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
    this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
    this.<span class="apidocCodeKeywordSpan">readBlockZip64EndOfCentral</span>();
}

var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
if (this.zip64) {
    expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
    expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.readBlockZip64EndOfCentralLocator" id="apidoc.element.jszip.zipEntries.prototype.readBlockZip64EndOfCentralLocator">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readBlockZip64EndOfCentralLocator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBlockZip64EndOfCentralLocator = function () {
    this.diskWithZip64CentralDirStart = this.reader.readInt(4);
    this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
    this.disksCount = this.reader.readInt(4);
    if (this.disksCount &gt; 1) {
        throw new Error("Multi-volumes zip are not supported");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// should look for a zip64 EOCD locator
offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
if (offset &lt; 0) {
    throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
}
this.reader.setIndex(offset);
this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
this.<span class="apidocCodeKeywordSpan">readBlockZip64EndOfCentralLocator</span>();

// now the zip64 EOCD record
if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
    // console.warn("ZIP64 end of central directory not where expected.");
    this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
    if (this.relativeOffsetEndOfZip64CentralDir &lt; 0) {
        throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.readCentralDir" id="apidoc.element.jszip.zipEntries.prototype.readCentralDir">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readCentralDir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readCentralDir = function () {
    var file;

    this.reader.setIndex(this.centralDirOffset);
    while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
        file = new ZipEntry({
            zip64: this.zip64
        }, this.loadOptions);
        file.readCentralPart(this.reader);
        this.files.push(file);
    }

    if (this.centralDirRecords !== this.files.length) {
        if (this.centralDirRecords !== 0 &amp;&amp; this.files.length === 0) {
            // We expected some records but couldn't find ANY.
            // This is really suspicious, as if something went wrong.
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.
files.length);
        } else {
            // We found some records but not all.
            // Something is wrong but we got something for the user: no error here.
            // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.<span class="apidocCodeKeywordSpan">readCentralDir</span>();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.readEndOfCentral" id="apidoc.element.jszip.zipEntries.prototype.readEndOfCentral">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readEndOfCentral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readEndOfCentral = function () {
    var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
    if (offset &lt; 0) {
        // Check if the content is a truncated zip or complete garbage.
        // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
        // extractible zip for example) but it can give a good hint.
        // If an ajax request was used without responseType, we will also
        // get unreadable data.
        var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

        if (isGarbage) {
            throw new Error("Can't find end of central directory : is this a zip file ? " +
                            "If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html");
        } else {
            throw new Error("Corrupted zip : can't find end of central directory");
        }

    }
    this.reader.setIndex(offset);
    var endOfCentralDirOffset = offset;
    this.checkSignature(sig.CENTRAL_DIRECTORY_END);
    this.readBlockEndOfCentral();


<span class="apidocCodeCommentSpan">    /* extract from the zip spec :
        4)  If one of the fields in the end of central directory
            record is too small to hold required data, the field
            should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
            ZIP64 format record should be created.
        5)  The end of central directory record and the
            Zip64 end of central directory locator record must
            reside on the same disk when splitting or spanning
            an archive.
     */
</span>    if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk
 === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS
 || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
        this.zip64 = true;

        /*
        Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
        the zip file can fit into a 32bits integer. This cannot be solved : Javascript represents
        all numbers as 64-bit double precision IEEE 754 floating point numbers.
        So, we have 53bits for integers and bitwise operations treat everything as 32bits.
        see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
        and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
        */

        // should look for a zip64 EOCD locator
        offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        if (offset &lt; 0) {
            throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
        }
        this.reader.setIndex(offset);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        this.readBlockZip64EndOfCentralLocator();

        // now the zip64 EOCD record
        if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
            // console.warn("ZIP64 end of central directory not where expected.");
            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            if (this.relativeOffsetEndOfZip64CentralDir &lt; 0) {
                throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
            }
        }
        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
        this.readBlockZip64EndOfCentral();
    }

    var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
    if (this.zip64) {
        expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
        expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
    }

    var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

    if (extraBytes &gt; 0) {
        // console.warn(extraBytes, "extra bytes at beginning or within zipfile"); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.prepareReader(data);
        this.<span class="apidocCodeKeywordSpan">readEndOfCentral</span>();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.readLocalFiles" id="apidoc.element.jszip.zipEntries.prototype.readLocalFiles">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readLocalFiles
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readLocalFiles = function () {
    var i, file;
    for (i = 0; i &lt; this.files.length; i++) {
        file = this.files[i];
        this.reader.setIndex(file.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file.readLocalPart(this.reader);
        file.handleUTF8();
        file.processAttributes();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.<span class="apidocCodeKeywordSpan">readLocalFiles</span>();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.zipEntry" id="apidoc.module.jszip.zipEntry">module jszip.zipEntry</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.zipEntry.zipEntry" id="apidoc.element.jszip.zipEntry.zipEntry">
        function <span class="apidocSignatureSpan">jszip.</span>zipEntry
        <span class="apidocSignatureSpan">(options, loadOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.zipEntry.prototype" id="apidoc.module.jszip.zipEntry.prototype">module jszip.zipEntry.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.findExtraFieldUnicodeComment" id="apidoc.element.jszip.zipEntry.prototype.findExtraFieldUnicodeComment">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>findExtraFieldUnicodeComment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findExtraFieldUnicodeComment = function () {
    var ucommentField = this.extraFields[0x6375];
    if (ucommentField) {
        var extraReader = readerFor(ucommentField.value);

        // wrong version
        if (extraReader.readInt(1) !== 1) {
            return null;
        }

        // the crc of the comment changed, this field is out of date.
        if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
            return null;
        }

        return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.fileNameStr = upath;
} else {
    // ASCII text or unsupported code page
    var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
    this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
}

var ucomment = this.<span class="apidocCodeKeywordSpan">findExtraFieldUnicodeComment</span>();
if (ucomment !== null) {
    this.fileCommentStr = ucomment;
} else {
    // ASCII text or unsupported code page
    var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);
    this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.findExtraFieldUnicodePath" id="apidoc.element.jszip.zipEntry.prototype.findExtraFieldUnicodePath">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>findExtraFieldUnicodePath
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findExtraFieldUnicodePath = function () {
    var upathField = this.extraFields[0x7075];
    if (upathField) {
        var extraReader = readerFor(upathField.value);

        // wrong version
        if (extraReader.readInt(1) !== 1) {
            return null;
        }

        // the crc of the filename changed, this field is out of date.
        if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
            return null;
        }

        return utf8.utf8decode(extraReader.readData(upathField.length - 5));
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
handleUTF8: function() {
    var decodeParamType = support.uint8array ? "uint8array" : "array";
    if (this.useUTF8()) {
        this.fileNameStr = utf8.utf8decode(this.fileName);
        this.fileCommentStr = utf8.utf8decode(this.fileComment);
    } else {
        var upath = this.<span class="apidocCodeKeywordSpan">findExtraFieldUnicodePath</span>();
        if (upath !== null) {
            this.fileNameStr = upath;
        } else {
            // ASCII text or unsupported code page
            var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.handleUTF8" id="apidoc.element.jszip.zipEntry.prototype.handleUTF8">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>handleUTF8
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleUTF8 = function () {
    var decodeParamType = support.uint8array ? "uint8array" : "array";
    if (this.useUTF8()) {
        this.fileNameStr = utf8.utf8decode(this.fileName);
        this.fileCommentStr = utf8.utf8decode(this.fileComment);
    } else {
        var upath = this.findExtraFieldUnicodePath();
        if (upath !== null) {
            this.fileNameStr = upath;
        } else {
            // ASCII text or unsupported code page
            var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
        }

        var ucomment = this.findExtraFieldUnicodeComment();
        if (ucomment !== null) {
            this.fileCommentStr = ucomment;
        } else {
            // ASCII text or unsupported code page
            var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
readLocalFiles: function() {
    var i, file;
    for (i = 0; i &lt; this.files.length; i++) {
        file = this.files[i];
        this.reader.setIndex(file.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file.readLocalPart(this.reader);
        file.<span class="apidocCodeKeywordSpan">handleUTF8</span>();
        file.processAttributes();
    }
},
/**
 * Read the central directory.
 */
readCentralDir: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.isEncrypted" id="apidoc.element.jszip.zipEntry.prototype.isEncrypted">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>isEncrypted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEncrypted = function () {
    // bit 1 is set
    return (this.bitFlag &amp; 0x0001) === 0x0001;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.extraFieldsLength = reader.readInt(2);
this.fileCommentLength = reader.readInt(2);
this.diskNumberStart = reader.readInt(2);
this.internalFileAttributes = reader.readInt(2);
this.externalFileAttributes = reader.readInt(4);
this.localHeaderOffset = reader.readInt(4);

if (this.<span class="apidocCodeKeywordSpan">isEncrypted</span>()) {
    throw new Error("Encrypted zip are not supported");
}

// will be read in the local part, see the comments there
reader.skip(fileNameLength);
this.readExtraFields(reader);
this.parseZIP64ExtraField(reader);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.parseZIP64ExtraField" id="apidoc.element.jszip.zipEntry.prototype.parseZIP64ExtraField">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>parseZIP64ExtraField
        <span class="apidocSignatureSpan">(reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseZIP64ExtraField = function (reader) {

    if (!this.extraFields[0x0001]) {
        return;
    }

    // should be something, preparing the extra reader
    var extraReader = readerFor(this.extraFields[0x0001].value);

    // I really hope that these 64bits integer can fit in 32 bits integer, because js
    // won't let us have more.
    if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
        this.uncompressedSize = extraReader.readInt(8);
    }
    if (this.compressedSize === utils.MAX_VALUE_32BITS) {
        this.compressedSize = extraReader.readInt(8);
    }
    if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
        this.localHeaderOffset = extraReader.readInt(8);
    }
    if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
        this.diskNumberStart = extraReader.readInt(4);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this.isEncrypted()) {
        throw new Error("Encrypted zip are not supported");
    }

    // will be read in the local part, see the comments there
    reader.skip(fileNameLength);
    this.readExtraFields(reader);
    this.<span class="apidocCodeKeywordSpan">parseZIP64ExtraField</span>(reader);
    this.fileComment = reader.readData(this.fileCommentLength);
},

/**
 * Parse the external file attributes and get the unix/dos permissions.
 */
processAttributes: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.processAttributes" id="apidoc.element.jszip.zipEntry.prototype.processAttributes">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>processAttributes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processAttributes = function () {
    this.unixPermissions = null;
    this.dosPermissions = null;
    var madeBy = this.versionMadeBy &gt;&gt; 8;

    // Check if we have the DOS directory flag set.
    // We look for it in the DOS and UNIX permissions
    // but some unknown platform could set it as a compatibility flag.
    this.dir = this.externalFileAttributes &amp; 0x0010 ? true : false;

    if(madeBy === MADE_BY_DOS) {
        // first 6 bits (0 to 5)
        this.dosPermissions = this.externalFileAttributes &amp; 0x3F;
    }

    if(madeBy === MADE_BY_UNIX) {
        this.unixPermissions = (this.externalFileAttributes &gt;&gt; 16) &amp; 0xFFFF;
        // the octal permissions are in (this.unixPermissions &amp; 0x01FF).toString(8);
    }

    // fail safe : if the name ends with a / it probably means a folder
    if (!this.dir &amp;&amp; this.fileNameStr.slice(-1) === '/') {
        this.dir = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var i, file;
    for (i = 0; i &lt; this.files.length; i++) {
        file = this.files[i];
        this.reader.setIndex(file.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file.readLocalPart(this.reader);
        file.handleUTF8();
        file.<span class="apidocCodeKeywordSpan">processAttributes</span>();
    }
},
/**
 * Read the central directory.
 */
readCentralDir: function() {
    var file;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.readCentralPart" id="apidoc.element.jszip.zipEntry.prototype.readCentralPart">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>readCentralPart
        <span class="apidocSignatureSpan">(reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readCentralPart = function (reader) {
    this.versionMadeBy = reader.readInt(2);
    reader.skip(2);
    // this.versionNeeded = reader.readInt(2);
    this.bitFlag = reader.readInt(2);
    this.compressionMethod = reader.readString(2);
    this.date = reader.readDate();
    this.crc32 = reader.readInt(4);
    this.compressedSize = reader.readInt(4);
    this.uncompressedSize = reader.readInt(4);
    var fileNameLength = reader.readInt(2);
    this.extraFieldsLength = reader.readInt(2);
    this.fileCommentLength = reader.readInt(2);
    this.diskNumberStart = reader.readInt(2);
    this.internalFileAttributes = reader.readInt(2);
    this.externalFileAttributes = reader.readInt(4);
    this.localHeaderOffset = reader.readInt(4);

    if (this.isEncrypted()) {
        throw new Error("Encrypted zip are not supported");
    }

    // will be read in the local part, see the comments there
    reader.skip(fileNameLength);
    this.readExtraFields(reader);
    this.parseZIP64ExtraField(reader);
    this.fileComment = reader.readData(this.fileCommentLength);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var file;

this.reader.setIndex(this.centralDirOffset);
while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
    file = new ZipEntry({
        zip64: this.zip64
    }, this.loadOptions);
    file.<span class="apidocCodeKeywordSpan">readCentralPart</span>(this.reader);
    this.files.push(file);
}

if (this.centralDirRecords !== this.files.length) {
    if (this.centralDirRecords !== 0 &amp;&amp; this.files.length === 0) {
        // We expected some records but couldn't find ANY.
        // This is really suspicious, as if something went wrong.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.readExtraFields" id="apidoc.element.jszip.zipEntry.prototype.readExtraFields">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>readExtraFields
        <span class="apidocSignatureSpan">(reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readExtraFields = function (reader) {
    var end = reader.index + this.extraFieldsLength,
        extraFieldId,
        extraFieldLength,
        extraFieldValue;

    if (!this.extraFields) {
        this.extraFields = {};
    }

    while (reader.index &lt; end) {
        extraFieldId = reader.readInt(2);
        extraFieldLength = reader.readInt(2);
        extraFieldValue = reader.readData(extraFieldLength);

        this.extraFields[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (this.isEncrypted()) {
        throw new Error("Encrypted zip are not supported");
    }

    // will be read in the local part, see the comments there
    reader.skip(fileNameLength);
    this.<span class="apidocCodeKeywordSpan">readExtraFields</span>(reader);
    this.parseZIP64ExtraField(reader);
    this.fileComment = reader.readData(this.fileCommentLength);
},

/**
 * Parse the external file attributes and get the unix/dos permissions.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.readLocalPart" id="apidoc.element.jszip.zipEntry.prototype.readLocalPart">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>readLocalPart
        <span class="apidocSignatureSpan">(reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readLocalPart = function (reader) {
    var compression, localExtraFieldsLength;

    // we already know everything from the central dir !
    // If the central dir data are false, we are doomed.
    // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
    // The less data we get here, the more reliable this should be.
    // Let's skip the whole header and dash to the data !
    reader.skip(22);
    // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
    // Strangely, the filename here is OK.
    // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
    // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
    // Search "unzip mismatching "local" filename continuing with "central" filename version" on
    // the internet.
    //
    // I think I see the logic here : the central directory is used to display
    // content and the local directory is used to extract the files. Mixing / and \
    // may be used to display \ to windows users and use / when extracting the files.
    // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
    this.fileNameLength = reader.readInt(2);
    localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
    // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
    this.fileName = reader.readData(this.fileNameLength);
    reader.skip(localExtraFieldsLength);

    if (this.compressedSize === -1 || this.uncompressedSize === -1) {
        throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -
1 || uncompressedSize === -1)");
    }

    compression = findCompression(this.compressionMethod);
    if (compression === null) { // no compression found
        throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils
.transformTo("string", this.fileName) + ")");
    }
    this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData
(this.compressedSize));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
readLocalFiles: function() {
    var i, file;
    for (i = 0; i &lt; this.files.length; i++) {
        file = this.files[i];
        this.reader.setIndex(file.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file.<span class="apidocCodeKeywordSpan">readLocalPart</span>(this.reader);
        file.handleUTF8();
        file.processAttributes();
    }
},
/**
 * Read the central directory.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.useUTF8" id="apidoc.element.jszip.zipEntry.prototype.useUTF8">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>useUTF8
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">useUTF8 = function () {
    // bit 11 is set
    return (this.bitFlag &amp; 0x0800) === 0x0800;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
},
/**
 * Apply an UTF8 transformation if needed.
 */
handleUTF8: function() {
    var decodeParamType = support.uint8array ? "uint8array" : "array";
    if (this.<span class="apidocCodeKeywordSpan">useUTF8</span>()) {
        this.fileNameStr = utf8.utf8decode(this.fileName);
        this.fileCommentStr = utf8.utf8decode(this.fileComment);
    } else {
        var upath = this.findExtraFieldUnicodePath();
        if (upath !== null) {
            this.fileNameStr = upath;
        } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.zipObject" id="apidoc.module.jszip.zipObject">module jszip.zipObject</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.zipObject.zipObject" id="apidoc.element.jszip.zipObject.zipObject">
        function <span class="apidocSignatureSpan">jszip.</span>zipObject
        <span class="apidocSignatureSpan">(name, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zipObject = function (name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression : options.compression,
        compressionOptions : options.compressionOptions
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.zipObject.prototype" id="apidoc.module.jszip.zipObject.prototype">module jszip.zipObject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype._compressWorker" id="apidoc.element.jszip.zipObject.prototype._compressWorker">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>_compressWorker
        <span class="apidocSignatureSpan">(compression, compressionOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compressWorker = function (compression, compressionOptions) {
    if (
        this._data instanceof CompressedObject &amp;&amp;
        this._data.compression.magic === compression.magic
    ) {
        return this._data.getCompressedWorker();
    } else {
        var result = this._decompressWorker();
        if(!this._dataBinary) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
        }
        return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype._decompressWorker" id="apidoc.element.jszip.zipObject.prototype._decompressWorker">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>_decompressWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_decompressWorker = function () {
    if (this._data instanceof CompressedObject) {
        return this._data.getContentWorker();
    } else if (this._data instanceof GenericWorker) {
        return this._data;
    } else {
        return new DataWorker(this._data);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     */
    internalStream: function (type) {
var outputType = type.toLowerCase();
var askUnicodeString = outputType === "string" || outputType === "text";
if (outputType === "binarystring" || outputType === "text") {
    outputType = "string";
}
var result = this.<span class="apidocCodeKeywordSpan">_decompressWorker</span>();

var isUnicodeString = !this._dataBinary;

if (isUnicodeString &amp;&amp; !askUnicodeString) {
    result = result.pipe(new utf8.Utf8EncodeWorker());
}
if (!isUnicodeString &amp;&amp; askUnicodeString) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.asArrayBuffer" id="apidoc.element.jszip.zipObject.prototype.asArrayBuffer">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asArrayBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asArrayBuffer = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.asBinary" id="apidoc.element.jszip.zipObject.prototype.asBinary">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asBinary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asBinary = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.asNodeBuffer" id="apidoc.element.jszip.zipObject.prototype.asNodeBuffer">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asNodeBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asNodeBuffer = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.asText" id="apidoc.element.jszip.zipObject.prototype.asText">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asText = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.asUint8Array" id="apidoc.element.jszip.zipObject.prototype.asUint8Array">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asUint8Array
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asUint8Array = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.async" id="apidoc.element.jszip.zipObject.prototype.async">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>async
        <span class="apidocSignatureSpan">(type, onUpdate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">async = function (type, onUpdate) {
    return this.internalStream(type).accumulate(onUpdate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.internalStream" id="apidoc.element.jszip.zipObject.prototype.internalStream">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>internalStream
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">internalStream = function (type) {
    var outputType = type.toLowerCase();
    var askUnicodeString = outputType === "string" || outputType === "text";
    if (outputType === "binarystring" || outputType === "text") {
        outputType = "string";
    }
    var result = this._decompressWorker();

    var isUnicodeString = !this._dataBinary;

    if (isUnicodeString &amp;&amp; !askUnicodeString) {
        result = result.pipe(new utf8.Utf8EncodeWorker());
    }
    if (!isUnicodeString &amp;&amp; askUnicodeString) {
        result = result.pipe(new utf8.Utf8DecodeWorker());
    }

    return new StreamHelper(result, outputType, "");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Prepare the content in the asked type.
 * @param {String} type the type of the result.
 * @param {Function} onUpdate a function to call on each internal update.
 * @return Promise the promise of the result.
 */
async: function (type, onUpdate) {
    return this.<span class="apidocCodeKeywordSpan">internalStream</span>(type).accumulate(onUpdate);
},

/**
 * Prepare the content as a nodejs stream.
 * @param {String} type the type of each chunk.
 * @param {Function} onUpdate a function to call on each internal update.
 * @return Stream the stream.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.nodeStream" id="apidoc.element.jszip.zipObject.prototype.nodeStream">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>nodeStream
        <span class="apidocSignatureSpan">(type, onUpdate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nodeStream = function (type, onUpdate) {
    return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>