<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/Stuk/jszip#readme">jszip (v3.1.3)</a>
</h1>
<h4>Create, read and edit .zip files with Javascript http://stuartk.com/jszip</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip">module jszip</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.jszip">
            function <span class="apidocSignatureSpan"></span>jszip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ArrayReader">
            function <span class="apidocSignatureSpan">jszip.</span>ArrayReader
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ConvertWorker">
            function <span class="apidocSignatureSpan">jszip.</span>ConvertWorker
            <span class="apidocSignatureSpan">(destType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.Crc32Probe">
            function <span class="apidocSignatureSpan">jszip.</span>Crc32Probe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataLengthProbe">
            function <span class="apidocSignatureSpan">jszip.</span>DataLengthProbe
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataReader">
            function <span class="apidocSignatureSpan">jszip.</span>DataReader
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataWorker">
            function <span class="apidocSignatureSpan">jszip.</span>DataWorker
            <span class="apidocSignatureSpan">(dataP)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker">
            function <span class="apidocSignatureSpan">jszip.</span>GenericWorker
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.NodeBufferReader">
            function <span class="apidocSignatureSpan">jszip.</span>NodeBufferReader
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.NodejsStreamInputAdapter">
            function <span class="apidocSignatureSpan">jszip.</span>NodejsStreamInputAdapter
            <span class="apidocSignatureSpan">(filename, stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.NodejsStreamOutputAdapter">
            function <span class="apidocSignatureSpan">jszip.</span>NodejsStreamOutputAdapter
            <span class="apidocSignatureSpan">(helper, options, updateCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.StreamHelper">
            function <span class="apidocSignatureSpan">jszip.</span>StreamHelper
            <span class="apidocSignatureSpan">(worker, outputType, mimeType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.StringReader">
            function <span class="apidocSignatureSpan">jszip.</span>StringReader
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.Uint8ArrayReader">
            function <span class="apidocSignatureSpan">jszip.</span>Uint8ArrayReader
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ZipFileWorker">
            function <span class="apidocSignatureSpan">jszip.</span>ZipFileWorker
            <span class="apidocSignatureSpan">(streamFiles, comment, platform, encodeFileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.compressedObject">
            function <span class="apidocSignatureSpan">jszip.</span>compressedObject
            <span class="apidocSignatureSpan">(compressedSize, uncompressedSize, crc32, compression, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.loadAsync">
            function <span class="apidocSignatureSpan">jszip.</span>loadAsync
            <span class="apidocSignatureSpan">(content, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries">
            function <span class="apidocSignatureSpan">jszip.</span>zipEntries
            <span class="apidocSignatureSpan">(loadOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry">
            function <span class="apidocSignatureSpan">jszip.</span>zipEntry
            <span class="apidocSignatureSpan">(options, loadOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject">
            function <span class="apidocSignatureSpan">jszip.</span>zipObject
            <span class="apidocSignatureSpan">(name, data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>ArrayReader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>ConvertWorker.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>Crc32Probe.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>DataLengthProbe.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>DataReader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>DataWorker.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>GenericWorker.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>NodeBufferReader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>NodejsStreamInputAdapter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>NodejsStreamOutputAdapter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>StreamHelper.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>StringReader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>Uint8ArrayReader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>ZipFileWorker.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>base64</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>compressedObject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>external</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>flate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>nodejsUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>object</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>support</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>utf8</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>zipEntries.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>zipEntry.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jszip.</span>zipObject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jszip.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.ArrayReader">module jszip.ArrayReader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ArrayReader.ArrayReader">
            function <span class="apidocSignatureSpan">jszip.</span>ArrayReader
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.ArrayReader.prototype">module jszip.ArrayReader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ArrayReader.prototype.byteAt">
            function <span class="apidocSignatureSpan">jszip.ArrayReader.prototype.</span>byteAt
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ArrayReader.prototype.lastIndexOfSignature">
            function <span class="apidocSignatureSpan">jszip.ArrayReader.prototype.</span>lastIndexOfSignature
            <span class="apidocSignatureSpan">(sig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ArrayReader.prototype.readAndCheckSignature">
            function <span class="apidocSignatureSpan">jszip.ArrayReader.prototype.</span>readAndCheckSignature
            <span class="apidocSignatureSpan">(sig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ArrayReader.prototype.readData">
            function <span class="apidocSignatureSpan">jszip.ArrayReader.prototype.</span>readData
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.ConvertWorker">module jszip.ConvertWorker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ConvertWorker.ConvertWorker">
            function <span class="apidocSignatureSpan">jszip.</span>ConvertWorker
            <span class="apidocSignatureSpan">(destType)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.ConvertWorker.prototype">module jszip.ConvertWorker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ConvertWorker.prototype.processChunk">
            function <span class="apidocSignatureSpan">jszip.ConvertWorker.prototype.</span>processChunk
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.Crc32Probe">module jszip.Crc32Probe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.Crc32Probe.Crc32Probe">
            function <span class="apidocSignatureSpan">jszip.</span>Crc32Probe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.Crc32Probe.prototype">module jszip.Crc32Probe.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.Crc32Probe.prototype.processChunk">
            function <span class="apidocSignatureSpan">jszip.Crc32Probe.prototype.</span>processChunk
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.DataLengthProbe">module jszip.DataLengthProbe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataLengthProbe.DataLengthProbe">
            function <span class="apidocSignatureSpan">jszip.</span>DataLengthProbe
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.DataLengthProbe.prototype">module jszip.DataLengthProbe.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataLengthProbe.prototype.processChunk">
            function <span class="apidocSignatureSpan">jszip.DataLengthProbe.prototype.</span>processChunk
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.DataReader">module jszip.DataReader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataReader.DataReader">
            function <span class="apidocSignatureSpan">jszip.</span>DataReader
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.DataReader.prototype">module jszip.DataReader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataReader.prototype.byteAt">
            function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>byteAt
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataReader.prototype.checkIndex">
            function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>checkIndex
            <span class="apidocSignatureSpan">(newIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataReader.prototype.checkOffset">
            function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>checkOffset
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataReader.prototype.lastIndexOfSignature">
            function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>lastIndexOfSignature
            <span class="apidocSignatureSpan">(sig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataReader.prototype.readAndCheckSignature">
            function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>readAndCheckSignature
            <span class="apidocSignatureSpan">(sig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataReader.prototype.readData">
            function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>readData
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataReader.prototype.readDate">
            function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>readDate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataReader.prototype.readInt">
            function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>readInt
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataReader.prototype.readString">
            function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>readString
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataReader.prototype.setIndex">
            function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>setIndex
            <span class="apidocSignatureSpan">(newIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataReader.prototype.skip">
            function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>skip
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.DataWorker">module jszip.DataWorker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataWorker.DataWorker">
            function <span class="apidocSignatureSpan">jszip.</span>DataWorker
            <span class="apidocSignatureSpan">(dataP)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.DataWorker.prototype">module jszip.DataWorker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataWorker.prototype._tick">
            function <span class="apidocSignatureSpan">jszip.DataWorker.prototype.</span>_tick
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataWorker.prototype._tickAndRepeat">
            function <span class="apidocSignatureSpan">jszip.DataWorker.prototype.</span>_tickAndRepeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataWorker.prototype.cleanUp">
            function <span class="apidocSignatureSpan">jszip.DataWorker.prototype.</span>cleanUp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.DataWorker.prototype.resume">
            function <span class="apidocSignatureSpan">jszip.DataWorker.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.GenericWorker">module jszip.GenericWorker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.GenericWorker">
            function <span class="apidocSignatureSpan">jszip.</span>GenericWorker
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.GenericWorker.prototype">module jszip.GenericWorker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.cleanUp">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>cleanUp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.emit">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>emit
            <span class="apidocSignatureSpan">(name, arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.end">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.error">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>error
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.flush">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.lock">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>lock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.mergeStreamInfo">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>mergeStreamInfo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.on">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>on
            <span class="apidocSignatureSpan">(name, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.pause">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.pipe">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>pipe
            <span class="apidocSignatureSpan">(next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.processChunk">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>processChunk
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.push">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>push
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.registerPrevious">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>registerPrevious
            <span class="apidocSignatureSpan">(previous)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.resume">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.toString">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.GenericWorker.prototype.withStreamInfo">
            function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>withStreamInfo
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.NodeBufferReader">module jszip.NodeBufferReader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.NodeBufferReader.NodeBufferReader">
            function <span class="apidocSignatureSpan">jszip.</span>NodeBufferReader
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.NodeBufferReader.prototype">module jszip.NodeBufferReader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.NodeBufferReader.prototype.readData">
            function <span class="apidocSignatureSpan">jszip.NodeBufferReader.prototype.</span>readData
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.NodejsStreamInputAdapter">module jszip.NodejsStreamInputAdapter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.NodejsStreamInputAdapter.NodejsStreamInputAdapter">
            function <span class="apidocSignatureSpan">jszip.</span>NodejsStreamInputAdapter
            <span class="apidocSignatureSpan">(filename, stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.NodejsStreamInputAdapter.prototype">module jszip.NodejsStreamInputAdapter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.NodejsStreamInputAdapter.prototype._bindStream">
            function <span class="apidocSignatureSpan">jszip.NodejsStreamInputAdapter.prototype.</span>_bindStream
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.NodejsStreamInputAdapter.prototype.pause">
            function <span class="apidocSignatureSpan">jszip.NodejsStreamInputAdapter.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.NodejsStreamInputAdapter.prototype.resume">
            function <span class="apidocSignatureSpan">jszip.NodejsStreamInputAdapter.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.NodejsStreamOutputAdapter">module jszip.NodejsStreamOutputAdapter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.NodejsStreamOutputAdapter.NodejsStreamOutputAdapter">
            function <span class="apidocSignatureSpan">jszip.</span>NodejsStreamOutputAdapter
            <span class="apidocSignatureSpan">(helper, options, updateCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.NodejsStreamOutputAdapter.super_">
            function <span class="apidocSignatureSpan">jszip.NodejsStreamOutputAdapter.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.NodejsStreamOutputAdapter.prototype">module jszip.NodejsStreamOutputAdapter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.NodejsStreamOutputAdapter.prototype._read">
            function <span class="apidocSignatureSpan">jszip.NodejsStreamOutputAdapter.prototype.</span>_read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.StreamHelper">module jszip.StreamHelper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.StreamHelper.StreamHelper">
            function <span class="apidocSignatureSpan">jszip.</span>StreamHelper
            <span class="apidocSignatureSpan">(worker, outputType, mimeType)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.StreamHelper.prototype">module jszip.StreamHelper.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.StreamHelper.prototype.accumulate">
            function <span class="apidocSignatureSpan">jszip.StreamHelper.prototype.</span>accumulate
            <span class="apidocSignatureSpan">(updateCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.StreamHelper.prototype.on">
            function <span class="apidocSignatureSpan">jszip.StreamHelper.prototype.</span>on
            <span class="apidocSignatureSpan">(evt, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.StreamHelper.prototype.pause">
            function <span class="apidocSignatureSpan">jszip.StreamHelper.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.StreamHelper.prototype.resume">
            function <span class="apidocSignatureSpan">jszip.StreamHelper.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.StreamHelper.prototype.toNodejsStream">
            function <span class="apidocSignatureSpan">jszip.StreamHelper.prototype.</span>toNodejsStream
            <span class="apidocSignatureSpan">(updateCb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.StringReader">module jszip.StringReader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.StringReader.StringReader">
            function <span class="apidocSignatureSpan">jszip.</span>StringReader
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.StringReader.prototype">module jszip.StringReader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.StringReader.prototype.byteAt">
            function <span class="apidocSignatureSpan">jszip.StringReader.prototype.</span>byteAt
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.StringReader.prototype.lastIndexOfSignature">
            function <span class="apidocSignatureSpan">jszip.StringReader.prototype.</span>lastIndexOfSignature
            <span class="apidocSignatureSpan">(sig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.StringReader.prototype.readAndCheckSignature">
            function <span class="apidocSignatureSpan">jszip.StringReader.prototype.</span>readAndCheckSignature
            <span class="apidocSignatureSpan">(sig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.StringReader.prototype.readData">
            function <span class="apidocSignatureSpan">jszip.StringReader.prototype.</span>readData
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.Uint8ArrayReader">module jszip.Uint8ArrayReader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.Uint8ArrayReader.Uint8ArrayReader">
            function <span class="apidocSignatureSpan">jszip.</span>Uint8ArrayReader
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.Uint8ArrayReader.prototype">module jszip.Uint8ArrayReader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.Uint8ArrayReader.prototype.readData">
            function <span class="apidocSignatureSpan">jszip.Uint8ArrayReader.prototype.</span>readData
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.ZipFileWorker">module jszip.ZipFileWorker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ZipFileWorker.ZipFileWorker">
            function <span class="apidocSignatureSpan">jszip.</span>ZipFileWorker
            <span class="apidocSignatureSpan">(streamFiles, comment, platform, encodeFileName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.ZipFileWorker.prototype">module jszip.ZipFileWorker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ZipFileWorker.prototype.closedSource">
            function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>closedSource
            <span class="apidocSignatureSpan">(streamInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ZipFileWorker.prototype.error">
            function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>error
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ZipFileWorker.prototype.flush">
            function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ZipFileWorker.prototype.lock">
            function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>lock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ZipFileWorker.prototype.openedSource">
            function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>openedSource
            <span class="apidocSignatureSpan">(streamInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ZipFileWorker.prototype.prepareNextSource">
            function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>prepareNextSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ZipFileWorker.prototype.push">
            function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>push
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ZipFileWorker.prototype.registerPrevious">
            function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>registerPrevious
            <span class="apidocSignatureSpan">(previous)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.ZipFileWorker.prototype.resume">
            function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.base64">module jszip.base64</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.base64.decode">
            function <span class="apidocSignatureSpan">jszip.base64.</span>decode
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.base64.encode">
            function <span class="apidocSignatureSpan">jszip.base64.</span>encode
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.compressedObject">module jszip.compressedObject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.compressedObject.compressedObject">
            function <span class="apidocSignatureSpan">jszip.</span>compressedObject
            <span class="apidocSignatureSpan">(compressedSize, uncompressedSize, crc32, compression, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.compressedObject.createWorkerFrom">
            function <span class="apidocSignatureSpan">jszip.compressedObject.</span>createWorkerFrom
            <span class="apidocSignatureSpan">(uncompressedWorker, compression, compressionOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.compressedObject.prototype">module jszip.compressedObject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.compressedObject.prototype.getCompressedWorker">
            function <span class="apidocSignatureSpan">jszip.compressedObject.prototype.</span>getCompressedWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.compressedObject.prototype.getContentWorker">
            function <span class="apidocSignatureSpan">jszip.compressedObject.prototype.</span>getContentWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.external">module jszip.external</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.external.Promise">
            function <span class="apidocSignatureSpan">jszip.external.</span>Promise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.flate">module jszip.flate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.flate.compressWorker">
            function <span class="apidocSignatureSpan">jszip.flate.</span>compressWorker
            <span class="apidocSignatureSpan">(compressionOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.flate.uncompressWorker">
            function <span class="apidocSignatureSpan">jszip.flate.</span>uncompressWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jszip.flate.</span>magic</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.index">module jszip.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.index.generateWorker">
            function <span class="apidocSignatureSpan">jszip.index.</span>generateWorker
            <span class="apidocSignatureSpan">(zip, options, comment)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.nodejsUtils">module jszip.nodejsUtils</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>isNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.nodejsUtils.isBuffer">
            function <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>isBuffer
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.nodejsUtils.isStream">
            function <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>isStream
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.nodejsUtils.newBuffer">
            function <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>newBuffer
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.object">module jszip.object</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.object.file">
            function <span class="apidocSignatureSpan">jszip.object.</span>file
            <span class="apidocSignatureSpan">(name, data, o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.object.filter">
            function <span class="apidocSignatureSpan">jszip.object.</span>filter
            <span class="apidocSignatureSpan">(search)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.object.folder">
            function <span class="apidocSignatureSpan">jszip.object.</span>folder
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.object.forEach">
            function <span class="apidocSignatureSpan">jszip.object.</span>forEach
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.object.generate">
            function <span class="apidocSignatureSpan">jszip.object.</span>generate
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.object.generateAsync">
            function <span class="apidocSignatureSpan">jszip.object.</span>generateAsync
            <span class="apidocSignatureSpan">(options, onUpdate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.object.generateInternalStream">
            function <span class="apidocSignatureSpan">jszip.object.</span>generateInternalStream
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.object.generateNodeStream">
            function <span class="apidocSignatureSpan">jszip.object.</span>generateNodeStream
            <span class="apidocSignatureSpan">(options, onUpdate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.object.load">
            function <span class="apidocSignatureSpan">jszip.object.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.object.loadAsync">
            function <span class="apidocSignatureSpan">jszip.object.</span>loadAsync
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.object.remove">
            function <span class="apidocSignatureSpan">jszip.object.</span>remove
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.utf8">module jszip.utf8</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utf8.Utf8DecodeWorker">
            function <span class="apidocSignatureSpan">jszip.utf8.</span>Utf8DecodeWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utf8.Utf8EncodeWorker">
            function <span class="apidocSignatureSpan">jszip.utf8.</span>Utf8EncodeWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utf8.utf8decode">
            function <span class="apidocSignatureSpan">jszip.utf8.</span>utf8decode
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utf8.utf8encode">
            function <span class="apidocSignatureSpan">jszip.utf8.</span>utf8encode
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.utils">module jszip.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.applyFromCharCode">
            function <span class="apidocSignatureSpan">jszip.utils.</span>applyFromCharCode
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.checkSupport">
            function <span class="apidocSignatureSpan">jszip.utils.</span>checkSupport
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.delay">
            function <span class="apidocSignatureSpan">jszip.utils.</span>delay
            <span class="apidocSignatureSpan">(callback, args, self)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.extend">
            function <span class="apidocSignatureSpan">jszip.utils.</span>extend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.getTypeOf">
            function <span class="apidocSignatureSpan">jszip.utils.</span>getTypeOf
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.inherits">
            function <span class="apidocSignatureSpan">jszip.utils.</span>inherits
            <span class="apidocSignatureSpan">(ctor, superCtor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.newBlob">
            function <span class="apidocSignatureSpan">jszip.utils.</span>newBlob
            <span class="apidocSignatureSpan">(parts, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.prepareContent">
            function <span class="apidocSignatureSpan">jszip.utils.</span>prepareContent
            <span class="apidocSignatureSpan">(name, inputData, isBinary, isOptimizedBinaryString, isBase64)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.pretty">
            function <span class="apidocSignatureSpan">jszip.utils.</span>pretty
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.utils.transformTo">
            function <span class="apidocSignatureSpan">jszip.utils.</span>transformTo
            <span class="apidocSignatureSpan">(outputType, input)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jszip.utils.</span>MAX_VALUE_16BITS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jszip.utils.</span>MAX_VALUE_32BITS</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.zipEntries">module jszip.zipEntries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.zipEntries">
            function <span class="apidocSignatureSpan">jszip.</span>zipEntries
            <span class="apidocSignatureSpan">(loadOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.zipEntries.prototype">module jszip.zipEntries.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.checkSignature">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>checkSignature
            <span class="apidocSignatureSpan">(expectedSignature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.isSignature">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>isSignature
            <span class="apidocSignatureSpan">(askedIndex, expectedSignature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.load">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>load
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.prepareReader">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>prepareReader
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.readBlockEndOfCentral">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readBlockEndOfCentral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.readBlockZip64EndOfCentral">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readBlockZip64EndOfCentral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.readBlockZip64EndOfCentralLocator">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readBlockZip64EndOfCentralLocator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.readCentralDir">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readCentralDir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.readEndOfCentral">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readEndOfCentral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntries.prototype.readLocalFiles">
            function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readLocalFiles
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.zipEntry">module jszip.zipEntry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.zipEntry">
            function <span class="apidocSignatureSpan">jszip.</span>zipEntry
            <span class="apidocSignatureSpan">(options, loadOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.zipEntry.prototype">module jszip.zipEntry.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.findExtraFieldUnicodeComment">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>findExtraFieldUnicodeComment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.findExtraFieldUnicodePath">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>findExtraFieldUnicodePath
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.handleUTF8">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>handleUTF8
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.isEncrypted">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>isEncrypted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.parseZIP64ExtraField">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>parseZIP64ExtraField
            <span class="apidocSignatureSpan">(reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.processAttributes">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>processAttributes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.readCentralPart">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>readCentralPart
            <span class="apidocSignatureSpan">(reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.readExtraFields">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>readExtraFields
            <span class="apidocSignatureSpan">(reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.readLocalPart">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>readLocalPart
            <span class="apidocSignatureSpan">(reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipEntry.prototype.useUTF8">
            function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>useUTF8
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.zipObject">module jszip.zipObject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.zipObject">
            function <span class="apidocSignatureSpan">jszip.</span>zipObject
            <span class="apidocSignatureSpan">(name, data, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jszip.zipObject.prototype">module jszip.zipObject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype._compressWorker">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>_compressWorker
            <span class="apidocSignatureSpan">(compression, compressionOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype._decompressWorker">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>_decompressWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.asArrayBuffer">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asArrayBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.asBinary">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asBinary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.asNodeBuffer">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asNodeBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.asText">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.asUint8Array">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asUint8Array
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.async">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>async
            <span class="apidocSignatureSpan">(type, onUpdate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.internalStream">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>internalStream
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jszip.zipObject.prototype.nodeStream">
            function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>nodeStream
            <span class="apidocSignatureSpan">(type, onUpdate)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip" id="apidoc.module.jszip">module jszip</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.jszip" id="apidoc.element.jszip.jszip">
        function <span class="apidocSignatureSpan"></span>jszip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSZip() {
    // if this constructor is&nbsp;used without&nbsp;`new`, it&nbsp;adds `new` before&nbsp;itself:
    if(!(this instanceof JSZip)) {
        return new JSZip();
    }

    if(arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }

    // object containing the files :
    // {
    //   "folder/" : {...},
    //   "folder/data.txt" : {...}
    // }
    this.files = {};

    this.comment = null;

    // Where we are in the hierarchy
    this.root = "";
    this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
            if (typeof this[i] !== "function") {
                newObj[i] = this[i];
            }
        }
        return newObj;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ArrayReader" id="apidoc.element.jszip.ArrayReader">
        function <span class="apidocSignatureSpan">jszip.</span>ArrayReader
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ArrayReader(data) {
    DataReader.call(this, data);
	for(var i = 0; i &lt; this.data.length; i++) {
		data[i] = data[i] &amp; 0xFF;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ConvertWorker" id="apidoc.element.jszip.ConvertWorker">
        function <span class="apidocSignatureSpan">jszip.</span>ConvertWorker
        <span class="apidocSignatureSpan">(destType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.Crc32Probe" id="apidoc.element.jszip.Crc32Probe">
        function <span class="apidocSignatureSpan">jszip.</span>Crc32Probe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataLengthProbe" id="apidoc.element.jszip.DataLengthProbe">
        function <span class="apidocSignatureSpan">jszip.</span>DataLengthProbe
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataReader" id="apidoc.element.jszip.DataReader">
        function <span class="apidocSignatureSpan">jszip.</span>DataReader
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataReader(data) {
    this.data = data; // type : see implementation
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataWorker" id="apidoc.element.jszip.DataWorker">
        function <span class="apidocSignatureSpan">jszip.</span>DataWorker
        <span class="apidocSignatureSpan">(dataP)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";

    this._tickScheduled = false;

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data &amp;&amp; data.length || 0;
        self.type = utils.getTypeOf(data);
        if(!self.isPaused) {
            self._tickAndRepeat();
        }
    }, function (e) {
        self.error(e);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker" id="apidoc.element.jszip.GenericWorker">
        function <span class="apidocSignatureSpan">jszip.</span>GenericWorker
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GenericWorker(name) {
    // the name of the worker
    this.name = name || "default";
    // an object containing metadata about the workers chain
    this.streamInfo = {};
    // an error which happened when the worker was paused
    this.generatedError = null;
    // an object containing metadata to be merged by this worker into the general metadata
    this.extraStreamInfo = {};
    // true if the stream is paused (and should not do anything), false otherwise
    this.isPaused = true;
    // true if the stream is finished (and should not do anything), false otherwise
    this.isFinished = false;
    // true if the stream is locked to prevent further structure updates (pipe), false otherwise
    this.isLocked = false;
    // the event listeners
    this._listeners = {
        'data':[],
        'end':[],
        'error':[]
    };
    // the previous worker, if any
    this.previous = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.NodeBufferReader" id="apidoc.element.jszip.NodeBufferReader">
        function <span class="apidocSignatureSpan">jszip.</span>NodeBufferReader
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.NodejsStreamInputAdapter" id="apidoc.element.jszip.NodejsStreamInputAdapter">
        function <span class="apidocSignatureSpan">jszip.</span>NodejsStreamInputAdapter
        <span class="apidocSignatureSpan">(filename, stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.NodejsStreamOutputAdapter" id="apidoc.element.jszip.NodejsStreamOutputAdapter">
        function <span class="apidocSignatureSpan">jszip.</span>NodejsStreamOutputAdapter
        <span class="apidocSignatureSpan">(helper, options, updateCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;

    var self = this;
    helper.on("data", function (data, meta) {
        if (!self.push(data)) {
            self._helper.pause();
        }
        if(updateCb) {
            updateCb(meta);
        }
    })
    .on("error", function(e) {
        self.emit('error', e);
    })
    .on("end", function () {
        self.push(null);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.StreamHelper" id="apidoc.element.jszip.StreamHelper">
        function <span class="apidocSignatureSpan">jszip.</span>StreamHelper
        <span class="apidocSignatureSpan">(worker, outputType, mimeType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch(outputType) {
        case "blob":
            internalType = "arraybuffer";
        break;
        case "arraybuffer":
            internalType = "uint8array";
        break;
        case "base64":
            internalType = "string";
        break;
    }

    try {
        // the type used internally
        this._internalType = internalType;
        // the type used to output results
        this._outputType = outputType;
        // the mime type
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        // the last workers can be rewired without issues but we need to
        // prevent any updates on previous workers.
        worker.lock();
    } catch(e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.StringReader" id="apidoc.element.jszip.StringReader">
        function <span class="apidocSignatureSpan">jszip.</span>StringReader
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StringReader(data) {
    DataReader.call(this, data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.Uint8ArrayReader" id="apidoc.element.jszip.Uint8ArrayReader">
        function <span class="apidocSignatureSpan">jszip.</span>Uint8ArrayReader
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ZipFileWorker" id="apidoc.element.jszip.ZipFileWorker">
        function <span class="apidocSignatureSpan">jszip.</span>ZipFileWorker
        <span class="apidocSignatureSpan">(streamFiles, comment, platform, encodeFileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    // The number of bytes written so far. This doesn't count accumulated chunks.
    this.bytesWritten = 0;
    // The comment of the zip file
    this.zipComment = comment;
    // The platform "generating" the zip file.
    this.zipPlatform = platform;
    // the function to encode file names and comments.
    this.encodeFileName = encodeFileName;
    // Should we stream the content of the files ?
    this.streamFiles = streamFiles;
    // If `streamFiles` is false, we will need to accumulate the content of the
    // files to calculate sizes / crc32 (and write them *before* the content).
    // This boolean indicates if we are accumulating chunks (it will change a lot
    // during the lifetime of this worker).
    this.accumulate = false;
    // The buffer receiving chunks when accumulating content.
    this.contentBuffer = [];
    // The list of generated directory records.
    this.dirRecords = [];
    // The offset (in bytes) from the beginning of the zip file for the current source.
    this.currentSourceOffset = 0;
    // The total number of entries in this zip file.
    this.entriesCount = 0;
    // the name of the file currently being added, null when handling the end of the zip file.
    // Used for the emited metadata.
    this.currentFile = null;



    this._sources = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.compressedObject" id="apidoc.element.jszip.compressedObject">
        function <span class="apidocSignatureSpan">jszip.</span>compressedObject
        <span class="apidocSignatureSpan">(compressedSize, uncompressedSize, crc32, compression, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.loadAsync" id="apidoc.element.jszip.loadAsync">
        function <span class="apidocSignatureSpan">jszip.</span>loadAsync
        <span class="apidocSignatureSpan">(content, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
JSZip.defaults = require('./defaults');

// TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327
JSZip.version = "3.1.3";

JSZip.loadAsync = function (content, options) {
    return new JSZip().<span class="apidocCodeKeywordSpan">loadAsync</span>(content, options);
};

JSZip.external = require("./external");
module.exports = JSZip;

},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11
:[function(require,module,exports){
'use strict';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries" id="apidoc.element.jszip.zipEntries">
        function <span class="apidocSignatureSpan">jszip.</span>zipEntries
        <span class="apidocSignatureSpan">(loadOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry" id="apidoc.element.jszip.zipEntry">
        function <span class="apidocSignatureSpan">jszip.</span>zipEntry
        <span class="apidocSignatureSpan">(options, loadOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject" id="apidoc.element.jszip.zipObject">
        function <span class="apidocSignatureSpan">jszip.</span>zipObject
        <span class="apidocSignatureSpan">(name, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zipObject = function (name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression : options.compression,
        compressionOptions : options.compressionOptions
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.ArrayReader" id="apidoc.module.jszip.ArrayReader">module jszip.ArrayReader</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.ArrayReader.ArrayReader" id="apidoc.element.jszip.ArrayReader.ArrayReader">
        function <span class="apidocSignatureSpan">jszip.</span>ArrayReader
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ArrayReader(data) {
    DataReader.call(this, data);
	for(var i = 0; i &lt; this.data.length; i++) {
		data[i] = data[i] &amp; 0xFF;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.ArrayReader.prototype" id="apidoc.module.jszip.ArrayReader.prototype">module jszip.ArrayReader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.ArrayReader.prototype.byteAt" id="apidoc.element.jszip.ArrayReader.prototype.byteAt">
        function <span class="apidocSignatureSpan">jszip.ArrayReader.prototype.</span>byteAt
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">byteAt = function (i) {
    return this.data[this.zero + i];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {number} the corresponding number.
 */
readInt: function(size) {
    var result = 0,
        i;
    this.checkOffset(size);
    for (i = this.index + size - 1; i &gt;= this.index; i--) {
        result = (result &lt;&lt; 8) + this.<span class="apidocCodeKeywordSpan">byteAt</span>(i);
    }
    this.index += size;
    return result;
},
/**
 * Get the next string with a given byte size.
 * @param {number} size the number of bytes to read.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ArrayReader.prototype.lastIndexOfSignature" id="apidoc.element.jszip.ArrayReader.prototype.lastIndexOfSignature">
        function <span class="apidocSignatureSpan">jszip.ArrayReader.prototype.</span>lastIndexOfSignature
        <span class="apidocSignatureSpan">(sig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastIndexOfSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i &gt;= 0; --i) {
        if (this.data[i] === sig0 &amp;&amp; this.data[i + 1] === sig1 &amp;&amp; this.data[i + 2] === sig2 &amp;&amp; this.data[i + 3] === sig3) {
            return i - this.zero;
        }
    }

    return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }
},
/**
 * Read the end of central directory.
 */
readEndOfCentral: function() {
    var offset = this.reader.<span class="apidocCodeKeywordSpan">lastIndexOfSignature</span>(sig.CENTRAL_DIRECTORY_END);
    if (offset &lt; 0) {
        // Check if the content is a truncated zip or complete garbage.
        // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
        // extractible zip for example) but it can give a good hint.
        // If an ajax request was used without responseType, we will also
        // get unreadable data.
        var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ArrayReader.prototype.readAndCheckSignature" id="apidoc.element.jszip.ArrayReader.prototype.readAndCheckSignature">
        function <span class="apidocSignatureSpan">jszip.ArrayReader.prototype.</span>readAndCheckSignature
        <span class="apidocSignatureSpan">(sig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readAndCheckSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3),
        data = this.readData(4);
    return sig0 === data[0] &amp;&amp; sig1 === data[1] &amp;&amp; sig2 === data[2] &amp;&amp; sig3 === data[3];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ZipEntries.prototype = {
/**
 * Check that the reader is on the speficied signature.
 * @param {string} expectedSignature the expected signature.
 * @throws {Error} if it is an other signature.
 */
checkSignature: function(expectedSignature) {
    if (!this.reader.<span class="apidocCodeKeywordSpan">readAndCheckSignature</span>(expectedSignature)) {
        this.reader.index -= 4;
        var signature = this.reader.readString(4);
        throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + "
;, expected " + utils.pretty(expectedSignature) + ")");
    }
},
/**
 * Check if the given signature is at the given index.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ArrayReader.prototype.readData" id="apidoc.element.jszip.ArrayReader.prototype.readData">
        function <span class="apidocSignatureSpan">jszip.ArrayReader.prototype.</span>readData
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readData = function (size) {
    this.checkOffset(size);
    if(size === 0) {
        return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
var sig0 = sig.charCodeAt(0),
    sig1 = sig.charCodeAt(1),
    sig2 = sig.charCodeAt(2),
    sig3 = sig.charCodeAt(3),
    data = this.<span class="apidocCodeKeywordSpan">readData</span>(4);
return sig0 === data[0] &amp;&amp; sig1 === data[1] &amp;&amp; sig2 === data[2] &amp;&amp; sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function(size) {
this.checkOffset(size);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.ConvertWorker" id="apidoc.module.jszip.ConvertWorker">module jszip.ConvertWorker</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.ConvertWorker.ConvertWorker" id="apidoc.element.jszip.ConvertWorker.ConvertWorker">
        function <span class="apidocSignatureSpan">jszip.</span>ConvertWorker
        <span class="apidocSignatureSpan">(destType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.ConvertWorker.prototype" id="apidoc.module.jszip.ConvertWorker.prototype">module jszip.ConvertWorker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.ConvertWorker.prototype.processChunk" id="apidoc.element.jszip.ConvertWorker.prototype.processChunk">
        function <span class="apidocSignatureSpan">jszip.ConvertWorker.prototype.</span>processChunk
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processChunk = function (chunk) {
    this.push({
        data : utils.transformTo(this.destType, chunk.data),
        meta : chunk.meta
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
this._sources.push(previous);
var self = this;

previous.on('data', function (chunk) {
    self.<span class="apidocCodeKeywordSpan">processChunk</span>(chunk);
});
previous.on('end', function () {
    self.closedSource(self.previous.streamInfo);
    if(self._sources.length) {
        self.prepareNextSource();
    } else {
        self.end();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.Crc32Probe" id="apidoc.module.jszip.Crc32Probe">module jszip.Crc32Probe</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.Crc32Probe.Crc32Probe" id="apidoc.element.jszip.Crc32Probe.Crc32Probe">
        function <span class="apidocSignatureSpan">jszip.</span>Crc32Probe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.Crc32Probe.prototype" id="apidoc.module.jszip.Crc32Probe.prototype">module jszip.Crc32Probe.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.Crc32Probe.prototype.processChunk" id="apidoc.element.jszip.Crc32Probe.prototype.processChunk">
        function <span class="apidocSignatureSpan">jszip.Crc32Probe.prototype.</span>processChunk
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processChunk = function (chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
this._sources.push(previous);
var self = this;

previous.on('data', function (chunk) {
    self.<span class="apidocCodeKeywordSpan">processChunk</span>(chunk);
});
previous.on('end', function () {
    self.closedSource(self.previous.streamInfo);
    if(self._sources.length) {
        self.prepareNextSource();
    } else {
        self.end();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.DataLengthProbe" id="apidoc.module.jszip.DataLengthProbe">module jszip.DataLengthProbe</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.DataLengthProbe.DataLengthProbe" id="apidoc.element.jszip.DataLengthProbe.DataLengthProbe">
        function <span class="apidocSignatureSpan">jszip.</span>DataLengthProbe
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.DataLengthProbe.prototype" id="apidoc.module.jszip.DataLengthProbe.prototype">module jszip.DataLengthProbe.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.DataLengthProbe.prototype.processChunk" id="apidoc.element.jszip.DataLengthProbe.prototype.processChunk">
        function <span class="apidocSignatureSpan">jszip.DataLengthProbe.prototype.</span>processChunk
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processChunk = function (chunk) {
    if(chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
this._sources.push(previous);
var self = this;

previous.on('data', function (chunk) {
    self.<span class="apidocCodeKeywordSpan">processChunk</span>(chunk);
});
previous.on('end', function () {
    self.closedSource(self.previous.streamInfo);
    if(self._sources.length) {
        self.prepareNextSource();
    } else {
        self.end();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.DataReader" id="apidoc.module.jszip.DataReader">module jszip.DataReader</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.DataReader.DataReader" id="apidoc.element.jszip.DataReader.DataReader">
        function <span class="apidocSignatureSpan">jszip.</span>DataReader
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataReader(data) {
    this.data = data; // type : see implementation
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.DataReader.prototype" id="apidoc.module.jszip.DataReader.prototype">module jszip.DataReader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.DataReader.prototype.byteAt" id="apidoc.element.jszip.DataReader.prototype.byteAt">
        function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>byteAt
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">byteAt = function (i) {
    // see implementations
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {number} the corresponding number.
 */
readInt: function(size) {
    var result = 0,
        i;
    this.checkOffset(size);
    for (i = this.index + size - 1; i &gt;= this.index; i--) {
        result = (result &lt;&lt; 8) + this.<span class="apidocCodeKeywordSpan">byteAt</span>(i);
    }
    this.index += size;
    return result;
},
/**
 * Get the next string with a given byte size.
 * @param {number} size the number of bytes to read.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataReader.prototype.checkIndex" id="apidoc.element.jszip.DataReader.prototype.checkIndex">
        function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>checkIndex
        <span class="apidocSignatureSpan">(newIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkIndex = function (newIndex) {
    if (this.length &lt; this.zero + newIndex || newIndex &lt; 0) {
        throw new Error("End of data reached (data length = " + this.length + ", asked index = " + (newIndex) + "). Corrupted zip
 ?");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
DataReader.prototype = {
/**
 * Check that the offset will not go too far.
 * @param {string} offset the additional offset to check.
 * @throws {Error} an Error if the offset is out of bounds.
 */
checkOffset: function(offset) {
    this.<span class="apidocCodeKeywordSpan">checkIndex</span>(this.index + offset);
},
/**
 * Check that the specifed index will not be too far.
 * @param {string} newIndex the index to check.
 * @throws {Error} an Error if the index is out of bounds.
 */
checkIndex: function(newIndex) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataReader.prototype.checkOffset" id="apidoc.element.jszip.DataReader.prototype.checkOffset">
        function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>checkOffset
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkOffset = function (offset) {
    this.checkIndex(this.index + offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        data = this.readData(4);
    return sig0 === data[0] &amp;&amp; sig1 === data[1] &amp;&amp; sig2 === data[2] &amp;&amp; sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function(size) {
    this.<span class="apidocCodeKeywordSpan">checkOffset</span>(size);
    if(size === 0) {
        return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataReader.prototype.lastIndexOfSignature" id="apidoc.element.jszip.DataReader.prototype.lastIndexOfSignature">
        function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>lastIndexOfSignature
        <span class="apidocSignatureSpan">(sig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastIndexOfSignature = function (sig) {
    // see implementations
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }
},
/**
 * Read the end of central directory.
 */
readEndOfCentral: function() {
    var offset = this.reader.<span class="apidocCodeKeywordSpan">lastIndexOfSignature</span>(sig.CENTRAL_DIRECTORY_END);
    if (offset &lt; 0) {
        // Check if the content is a truncated zip or complete garbage.
        // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
        // extractible zip for example) but it can give a good hint.
        // If an ajax request was used without responseType, we will also
        // get unreadable data.
        var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataReader.prototype.readAndCheckSignature" id="apidoc.element.jszip.DataReader.prototype.readAndCheckSignature">
        function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>readAndCheckSignature
        <span class="apidocSignatureSpan">(sig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readAndCheckSignature = function (sig) {
    // see implementations
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ZipEntries.prototype = {
/**
 * Check that the reader is on the speficied signature.
 * @param {string} expectedSignature the expected signature.
 * @throws {Error} if it is an other signature.
 */
checkSignature: function(expectedSignature) {
    if (!this.reader.<span class="apidocCodeKeywordSpan">readAndCheckSignature</span>(expectedSignature)) {
        this.reader.index -= 4;
        var signature = this.reader.readString(4);
        throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + "
;, expected " + utils.pretty(expectedSignature) + ")");
    }
},
/**
 * Check if the given signature is at the given index.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataReader.prototype.readData" id="apidoc.element.jszip.DataReader.prototype.readData">
        function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>readData
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readData = function (size) {
    // see implementations
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
var sig0 = sig.charCodeAt(0),
    sig1 = sig.charCodeAt(1),
    sig2 = sig.charCodeAt(2),
    sig3 = sig.charCodeAt(3),
    data = this.<span class="apidocCodeKeywordSpan">readData</span>(4);
return sig0 === data[0] &amp;&amp; sig1 === data[1] &amp;&amp; sig2 === data[2] &amp;&amp; sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function(size) {
this.checkOffset(size);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataReader.prototype.readDate" id="apidoc.element.jszip.DataReader.prototype.readDate">
        function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>readDate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readDate = function () {
    var dostime = this.readInt(4);
    return new Date(Date.UTC(
    ((dostime &gt;&gt; 25) &amp; 0x7f) + 1980, // year
    ((dostime &gt;&gt; 21) &amp; 0x0f) - 1, // month
    (dostime &gt;&gt; 16) &amp; 0x1f, // day
    (dostime &gt;&gt; 11) &amp; 0x1f, // hour
    (dostime &gt;&gt; 5) &amp; 0x3f, // minute
    (dostime &amp; 0x1f) &lt;&lt; 1)); // second
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
readCentralPart: function(reader) {
    this.versionMadeBy = reader.readInt(2);
    reader.skip(2);
    // this.versionNeeded = reader.readInt(2);
    this.bitFlag = reader.readInt(2);
    this.compressionMethod = reader.readString(2);
    this.date = reader.<span class="apidocCodeKeywordSpan">readDate</span>();
    this.crc32 = reader.readInt(4);
    this.compressedSize = reader.readInt(4);
    this.uncompressedSize = reader.readInt(4);
    var fileNameLength = reader.readInt(2);
    this.extraFieldsLength = reader.readInt(2);
    this.fileCommentLength = reader.readInt(2);
    this.diskNumberStart = reader.readInt(2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataReader.prototype.readInt" id="apidoc.element.jszip.DataReader.prototype.readInt">
        function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>readInt
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt = function (size) {
    var result = 0,
        i;
    this.checkOffset(size);
    for (i = this.index + size - 1; i &gt;= this.index; i--) {
        result = (result &lt;&lt; 8) + this.byteAt(i);
    }
    this.index += size;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // see implementations
},
/**
 * Get the next date.
 * @return {Date} the date.
 */
readDate: function() {
    var dostime = this.<span class="apidocCodeKeywordSpan">readInt</span>(4);
    return new Date(Date.UTC(
    ((dostime &gt;&gt; 25) &amp; 0x7f) + 1980, // year
    ((dostime &gt;&gt; 21) &amp; 0x0f) - 1, // month
    (dostime &gt;&gt; 16) &amp; 0x1f, // day
    (dostime &gt;&gt; 11) &amp; 0x1f, // hour
    (dostime &gt;&gt; 5) &amp; 0x3f, // minute
    (dostime &amp; 0x1f) &lt;&lt; 1)); // second
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataReader.prototype.readString" id="apidoc.element.jszip.DataReader.prototype.readString">
        function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>readString
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readString = function (size) {
    return utils.transformTo("string", this.readData(size));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Check that the reader is on the speficied signature.
 * @param {string} expectedSignature the expected signature.
 * @throws {Error} if it is an other signature.
 */
checkSignature: function(expectedSignature) {
    if (!this.reader.readAndCheckSignature(expectedSignature)) {
        this.reader.index -= 4;
        var signature = this.reader.<span class="apidocCodeKeywordSpan">readString</span>(4);
        throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + "
;, expected " + utils.pretty(expectedSignature) + ")");
    }
},
/**
 * Check if the given signature is at the given index.
 * @param {number} askedIndex the index to check.
 * @param {string} expectedSignature the signature to expect.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataReader.prototype.setIndex" id="apidoc.element.jszip.DataReader.prototype.setIndex">
        function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>setIndex
        <span class="apidocSignatureSpan">(newIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setIndex = function (newIndex) {
    this.checkIndex(newIndex);
    this.index = newIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},
/**
 * Skip the next n bytes.
 * @param {number} n the number of bytes to skip.
 * @throws {Error} if the new index is out of the data.
 */
skip: function(n) {
    this.<span class="apidocCodeKeywordSpan">setIndex</span>(this.index + n);
},
/**
 * Get the byte at the specified index.
 * @param {number} i the index to use.
 * @return {number} a byte.
 */
byteAt: function(i) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataReader.prototype.skip" id="apidoc.element.jszip.DataReader.prototype.skip">
        function <span class="apidocSignatureSpan">jszip.DataReader.prototype.</span>skip
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function (n) {
    this.setIndex(this.index + n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Read the end of the Zip 64 central directory.
 * Not merged with the method readEndOfCentral :
 * The end of central can coexist with its Zip64 brother,
 * I don't want to read the wrong number of bytes !
 */
readBlockZip64EndOfCentral: function() {
    this.zip64EndOfCentralSize = this.reader.readInt(8);
    this.reader.<span class="apidocCodeKeywordSpan">skip</span>(4);
    // this.versionMadeBy = this.reader.readString(2);
    // this.versionNeeded = this.reader.readInt(2);
    this.diskNumber = this.reader.readInt(4);
    this.diskWithCentralDirStart = this.reader.readInt(4);
    this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
    this.centralDirRecords = this.reader.readInt(8);
    this.centralDirSize = this.reader.readInt(8);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.DataWorker" id="apidoc.module.jszip.DataWorker">module jszip.DataWorker</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.DataWorker.DataWorker" id="apidoc.element.jszip.DataWorker.DataWorker">
        function <span class="apidocSignatureSpan">jszip.</span>DataWorker
        <span class="apidocSignatureSpan">(dataP)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";

    this._tickScheduled = false;

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data &amp;&amp; data.length || 0;
        self.type = utils.getTypeOf(data);
        if(!self.isPaused) {
            self._tickAndRepeat();
        }
    }, function (e) {
        self.error(e);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.DataWorker.prototype" id="apidoc.module.jszip.DataWorker.prototype">module jszip.DataWorker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.DataWorker.prototype._tick" id="apidoc.element.jszip.DataWorker.prototype._tick">
        function <span class="apidocSignatureSpan">jszip.DataWorker.prototype.</span>_tick
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_tick = function () {

    if(this.isPaused || this.isFinished) {
        return false;
    }

    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index &gt;= this.max) {
        // EOF
        return this.end();
    } else {
        switch(this.type) {
            case "string":
                data = this.data.substring(this.index, nextIndex);
            break;
            case "uint8array":
                data = this.data.subarray(this.index, nextIndex);
            break;
            case "array":
            case "nodebuffer":
                data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
            data : data,
            meta : {
                percent : this.max ? this.index / this.max * 100 : 0
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Trigger a tick a schedule an other call to this function.
 */
DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if(this.isPaused || this.isFinished) {
        return;
    }
    this.<span class="apidocCodeKeywordSpan">_tick</span>();
    if(!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
    }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataWorker.prototype._tickAndRepeat" id="apidoc.element.jszip.DataWorker.prototype._tickAndRepeat">
        function <span class="apidocSignatureSpan">jszip.DataWorker.prototype.</span>_tickAndRepeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_tickAndRepeat = function () {
    this._tickScheduled = false;
    if(this.isPaused || this.isFinished) {
        return;
    }
    this._tick();
    if(!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data &amp;&amp; data.length || 0;
        self.type = utils.getTypeOf(data);
        if(!self.isPaused) {
            self.<span class="apidocCodeKeywordSpan">_tickAndRepeat</span>();
        }
    }, function (e) {
        self.error(e);
    });
}

utils.inherits(DataWorker, GenericWorker);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataWorker.prototype.cleanUp" id="apidoc.element.jszip.DataWorker.prototype.cleanUp">
        function <span class="apidocSignatureSpan">jszip.DataWorker.prototype.</span>cleanUp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this.isFinished) {
        return false;
    }

    this.flush();
    try {
        this.emit("end");
        this.<span class="apidocCodeKeywordSpan">cleanUp</span>();
        this.isFinished = true;
    } catch (e) {
        this.emit("error", e);
    }
    return true;
},
/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.DataWorker.prototype.resume" id="apidoc.element.jszip.DataWorker.prototype.resume">
        function <span class="apidocSignatureSpan">jszip.DataWorker.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this._tickScheduled &amp;&amp; this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.<span class="apidocCodeKeywordSpan">resume</span>();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.GenericWorker" id="apidoc.module.jszip.GenericWorker">module jszip.GenericWorker</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.GenericWorker" id="apidoc.element.jszip.GenericWorker.GenericWorker">
        function <span class="apidocSignatureSpan">jszip.</span>GenericWorker
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GenericWorker(name) {
    // the name of the worker
    this.name = name || "default";
    // an object containing metadata about the workers chain
    this.streamInfo = {};
    // an error which happened when the worker was paused
    this.generatedError = null;
    // an object containing metadata to be merged by this worker into the general metadata
    this.extraStreamInfo = {};
    // true if the stream is paused (and should not do anything), false otherwise
    this.isPaused = true;
    // true if the stream is finished (and should not do anything), false otherwise
    this.isFinished = false;
    // true if the stream is locked to prevent further structure updates (pipe), false otherwise
    this.isLocked = false;
    // the event listeners
    this._listeners = {
        'data':[],
        'end':[],
        'error':[]
    };
    // the previous worker, if any
    this.previous = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.GenericWorker.prototype" id="apidoc.module.jszip.GenericWorker.prototype">module jszip.GenericWorker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.cleanUp" id="apidoc.element.jszip.GenericWorker.prototype.cleanUp">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>cleanUp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanUp = function () {
    this.streamInfo = this.generatedError = this.extraStreamInfo = null;
    this._listeners = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this.isFinished) {
        return false;
    }

    this.flush();
    try {
        this.emit("end");
        this.<span class="apidocCodeKeywordSpan">cleanUp</span>();
        this.isFinished = true;
    } catch (e) {
        this.emit("error", e);
    }
    return true;
},
/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.emit" id="apidoc.element.jszip.GenericWorker.prototype.emit">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>emit
        <span class="apidocSignatureSpan">(name, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (name, arg) {
    if (this._listeners[name]) {
        for(var i = 0; i &lt; this._listeners[name].length; i++) {
            this._listeners[name][i].call(this, arg);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            self._helper.pause();
        }
        if(updateCb) {
            updateCb(meta);
        }
    })
    .on("error", function(e) {
        self.<span class="apidocCodeKeywordSpan">emit</span>('error', e);
    })
    .on("end", function () {
        self.push(null);
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.end" id="apidoc.element.jszip.GenericWorker.prototype.end">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
    if (this.isFinished) {
        return false;
    }

    this.flush();
    try {
        this.emit("end");
        this.cleanUp();
        this.isFinished = true;
    } catch (e) {
        this.emit("error", e);
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.closedSource(self.previous.streamInfo);
        if(self._sources.length) {
            self.prepareNextSource();
        } else {
            self.<span class="apidocCodeKeywordSpan">end</span>();
        }
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.error" id="apidoc.element.jszip.GenericWorker.prototype.error">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>error
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (e) {
    if (this.isFinished) {
        return false;
    }

    if(this.isPaused) {
        this.generatedError = e;
    } else {
        this.isFinished = true;

        this.emit("error", e);

        // in the workers chain exploded in the middle of the chain,
        // the error event will go downward but we also need to notify
        // workers upward that there has been an error.
        if(this.previous) {
            this.previous.error(e);
        }

        this.cleanUp();
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       if(self._sources.length) {
           self.prepareNextSource();
       } else {
           self.end();
       }
   });
   previous.on('error', function (e) {
       self.<span class="apidocCodeKeywordSpan">error</span>(e);
   });
   return this;
};

/**
* @see GenericWorker.resume
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.flush" id="apidoc.element.jszip.GenericWorker.prototype.flush">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end : function () {
if (this.isFinished) {
    return false;
}

this.<span class="apidocCodeKeywordSpan">flush</span>();
try {
    this.emit("end");
    this.cleanUp();
    this.isFinished = true;
} catch (e) {
    this.emit("error", e);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.lock" id="apidoc.element.jszip.GenericWorker.prototype.lock">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>lock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lock = function () {
    if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
    }
    this.isLocked = true;
    if (this.previous) {
        this.previous.lock();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * @see GenericWorker.lock
 */
ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for(var i = 0; i &lt; sources.length; i++) {
        sources[i].<span class="apidocCodeKeywordSpan">lock</span>();
    }
};

module.exports = ZipFileWorker;

},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils
":32}],9:[function(require,module,exports){
'use strict';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.mergeStreamInfo" id="apidoc.element.jszip.GenericWorker.prototype.mergeStreamInfo">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>mergeStreamInfo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeStreamInfo = function () {
    for(var key in this.extraStreamInfo) {
        if (!this.extraStreamInfo.hasOwnProperty(key)) {
            continue;
        }
        this.streamInfo[key] = this.extraStreamInfo[key];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.isLocked) {
    throw new Error("The stream '" + this + "' has already been used.");
}

// sharing the streamInfo...
this.streamInfo = previous.streamInfo;
// ... and adding our own bits
this.<span class="apidocCodeKeywordSpan">mergeStreamInfo</span>();
this.previous =  previous;
var self = this;
previous.on('data', function (chunk) {
    self.processChunk(chunk);
});
previous.on('end', function () {
    self.end();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.on" id="apidoc.element.jszip.GenericWorker.prototype.on">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>on
        <span class="apidocSignatureSpan">(name, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (name, listener) {
    this._listeners[name].push(listener);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
getContentWorker : function () {
    var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
    .pipe(this.compression.uncompressWorker())
    .pipe(new DataLengthProbe("data_length"));

    var that = this;
    worker.<span class="apidocCodeKeywordSpan">on</span>("end", function () {
        if(this.streamInfo['data_length'] !== that.uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
        }
    });
    return worker;
},
/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.pause" id="apidoc.element.jszip.GenericWorker.prototype.pause">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
    if(this.isPaused || this.isFinished) {
        return false;
    }
    this.isPaused = true;

    if(this.previous) {
        this.previous.pause();
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Prepare the next source to be read.
*/
ZipFileWorker.prototype.prepareNextSource = function () {
   this.previous = this._sources.shift();
   this.openedSource(this.previous.streamInfo);
   if (this.isPaused) {
       this.previous.<span class="apidocCodeKeywordSpan">pause</span>();
   } else {
       this.previous.resume();
   }
};

/**
* @see GenericWorker.registerPrevious
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.pipe" id="apidoc.element.jszip.GenericWorker.prototype.pipe">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>pipe
        <span class="apidocSignatureSpan">(next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (next) {
    return next.registerPrevious(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker : function () {
var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
.<span class="apidocCodeKeywordSpan">pipe</span>(this.compression.uncompressWorker())
.pipe(new DataLengthProbe("data_length"));

var that = this;
worker.on("end", function () {
    if(this.streamInfo['data_length'] !== that.uncompressedSize) {
        throw new Error("Bug : uncompressed data size mismatch");
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.processChunk" id="apidoc.element.jszip.GenericWorker.prototype.processChunk">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>processChunk
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processChunk = function (chunk) {
    this.push(chunk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
this._sources.push(previous);
var self = this;

previous.on('data', function (chunk) {
    self.<span class="apidocCodeKeywordSpan">processChunk</span>(chunk);
});
previous.on('end', function () {
    self.closedSource(self.previous.streamInfo);
    if(self._sources.length) {
        self.prepareNextSource();
    } else {
        self.end();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.push" id="apidoc.element.jszip.GenericWorker.prototype.push">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>push
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (chunk) {
    this.emit("data", chunk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        enc1 = chr1 &gt;&gt; 2;
        enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4);
        enc3 = remainingBytes &gt; 1 ? (((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6)) : 64;
        enc4 = remainingBytes &gt; 2 ? (chr3 &amp; 63) : 64;

        output.<span class="apidocCodeKeywordSpan">push</span>(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3
) + _keyStr.charAt(enc4));

    }

    return output.join("");
};

// public method for decoding
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.registerPrevious" id="apidoc.element.jszip.GenericWorker.prototype.registerPrevious">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>registerPrevious
        <span class="apidocSignatureSpan">(previous)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerPrevious = function (previous) {
    if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
    }

    // sharing the streamInfo...
    this.streamInfo = previous.streamInfo;
    // ... and adding our own bits
    this.mergeStreamInfo();
    this.previous =  previous;
    var self = this;
    previous.on('data', function (chunk) {
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.end();
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},
/**
 * Chain a worker with an other.
 * @param {Worker} next the worker receiving events from the current one.
 * @return {worker} the next worker for chainability
 */
pipe : function (next) {
    return next.<span class="apidocCodeKeywordSpan">registerPrevious</span>(this);
},
/**
 * Same as `pipe` in the other direction.
 * Using an API with `pipe(next)` is very easy.
 * Implementing the API with the point of view of the next one registering
 * a source is easier, see the ZipFileWorker.
 * @param {Worker} previous the previous worker, sending events to this one
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.resume" id="apidoc.element.jszip.GenericWorker.prototype.resume">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
    if(!this.isPaused || this.isFinished) {
        return false;
    }
    this.isPaused = false;

    // if true, the worker tried to resume but failed
    var withError = false;
    if(this.generatedError) {
        this.error(this.generatedError);
        withError = true;
    }
    if(this.previous) {
        this.previous.resume();
    }

    return !withError;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.<span class="apidocCodeKeywordSpan">resume</span>();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.toString" id="apidoc.element.jszip.GenericWorker.prototype.toString">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    var me = "Worker " + this.name;
    if (this.previous) {
        return this.previous + " -&gt; " + me;
    } else {
        return me;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).<span class="apidocCodeKeywordSpan">toString</span>("utf-8"
;);
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.GenericWorker.prototype.withStreamInfo" id="apidoc.element.jszip.GenericWorker.prototype.withStreamInfo">
        function <span class="apidocSignatureSpan">jszip.GenericWorker.prototype.</span>withStreamInfo
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withStreamInfo = function (key, value) {
    this.extraStreamInfo[key] = value;
    this.mergeStreamInfo();
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker : function () {
        return new DataWorker(external.Promise.resolve(this.compressedContent))
        .<span class="apidocCodeKeywordSpan">withStreamInfo</span>("compressedSize", this.compressedSize)
        .withStreamInfo("uncompressedSize", this.uncompressedSize)
        .withStreamInfo("crc32", this.crc32)
        .withStreamInfo("compression", this.compression)
        ;
    }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.NodeBufferReader" id="apidoc.module.jszip.NodeBufferReader">module jszip.NodeBufferReader</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.NodeBufferReader.NodeBufferReader" id="apidoc.element.jszip.NodeBufferReader.NodeBufferReader">
        function <span class="apidocSignatureSpan">jszip.</span>NodeBufferReader
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.NodeBufferReader.prototype" id="apidoc.module.jszip.NodeBufferReader.prototype">module jszip.NodeBufferReader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.NodeBufferReader.prototype.readData" id="apidoc.element.jszip.NodeBufferReader.prototype.readData">
        function <span class="apidocSignatureSpan">jszip.NodeBufferReader.prototype.</span>readData
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readData = function (size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
var sig0 = sig.charCodeAt(0),
    sig1 = sig.charCodeAt(1),
    sig2 = sig.charCodeAt(2),
    sig3 = sig.charCodeAt(3),
    data = this.<span class="apidocCodeKeywordSpan">readData</span>(4);
return sig0 === data[0] &amp;&amp; sig1 === data[1] &amp;&amp; sig2 === data[2] &amp;&amp; sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function(size) {
this.checkOffset(size);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.NodejsStreamInputAdapter" id="apidoc.module.jszip.NodejsStreamInputAdapter">module jszip.NodejsStreamInputAdapter</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.NodejsStreamInputAdapter.NodejsStreamInputAdapter" id="apidoc.element.jszip.NodejsStreamInputAdapter.NodejsStreamInputAdapter">
        function <span class="apidocSignatureSpan">jszip.</span>NodejsStreamInputAdapter
        <span class="apidocSignatureSpan">(filename, stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.NodejsStreamInputAdapter.prototype" id="apidoc.module.jszip.NodejsStreamInputAdapter.prototype">module jszip.NodejsStreamInputAdapter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.NodejsStreamInputAdapter.prototype._bindStream" id="apidoc.element.jszip.NodejsStreamInputAdapter.prototype._bindStream">
        function <span class="apidocSignatureSpan">jszip.NodejsStreamInputAdapter.prototype.</span>_bindStream
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_bindStream = function (stream) {
    var self = this;
    this._stream = stream;
    stream.pause();
    stream
    .on("data", function (chunk) {
        self.push({
            data: chunk,
            meta : {
                percent : 0
            }
        });
    })
    .on("error", function (e) {
        if(self.isPaused) {
            this.generatedError = e;
        } else {
            self.error(e);
        }
    })
    .on("end", function () {
        if(self.isPaused) {
            self._upstreamEnded = true;
        } else {
            self.end();
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @constructor
* @param {String} filename the name of the file entry for this stream.
* @param {Readable} stream the nodejs stream.
*/
function NodejsStreamInputAdapter(filename, stream) {
   GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
   this._upstreamEnded = false;
   this.<span class="apidocCodeKeywordSpan">_bindStream</span>(stream);
}

utils.inherits(NodejsStreamInputAdapter, GenericWorker);

/**
* Prepare the stream and bind the callbacks on it.
* Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.NodejsStreamInputAdapter.prototype.pause" id="apidoc.element.jszip.NodejsStreamInputAdapter.prototype.pause">
        function <span class="apidocSignatureSpan">jszip.NodejsStreamInputAdapter.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
    if(!GenericWorker.prototype.pause.call(this)) {
        return false;
    }
    this._stream.pause();
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Prepare the next source to be read.
*/
ZipFileWorker.prototype.prepareNextSource = function () {
   this.previous = this._sources.shift();
   this.openedSource(this.previous.streamInfo);
   if (this.isPaused) {
       this.previous.<span class="apidocCodeKeywordSpan">pause</span>();
   } else {
       this.previous.resume();
   }
};

/**
* @see GenericWorker.registerPrevious
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.NodejsStreamInputAdapter.prototype.resume" id="apidoc.element.jszip.NodejsStreamInputAdapter.prototype.resume">
        function <span class="apidocSignatureSpan">jszip.NodejsStreamInputAdapter.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if(this._upstreamEnded) {
        this.end();
    } else {
        this._stream.resume();
    }

    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.<span class="apidocCodeKeywordSpan">resume</span>();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.NodejsStreamOutputAdapter" id="apidoc.module.jszip.NodejsStreamOutputAdapter">module jszip.NodejsStreamOutputAdapter</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.NodejsStreamOutputAdapter.NodejsStreamOutputAdapter" id="apidoc.element.jszip.NodejsStreamOutputAdapter.NodejsStreamOutputAdapter">
        function <span class="apidocSignatureSpan">jszip.</span>NodejsStreamOutputAdapter
        <span class="apidocSignatureSpan">(helper, options, updateCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;

    var self = this;
    helper.on("data", function (data, meta) {
        if (!self.push(data)) {
            self._helper.pause();
        }
        if(updateCb) {
            updateCb(meta);
        }
    })
    .on("error", function(e) {
        self.emit('error', e);
    })
    .on("end", function () {
        self.push(null);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.NodejsStreamOutputAdapter.super_" id="apidoc.element.jszip.NodejsStreamOutputAdapter.super_">
        function <span class="apidocSignatureSpan">jszip.NodejsStreamOutputAdapter.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options &amp;&amp; typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.NodejsStreamOutputAdapter.prototype" id="apidoc.module.jszip.NodejsStreamOutputAdapter.prototype">module jszip.NodejsStreamOutputAdapter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.NodejsStreamOutputAdapter.prototype._read" id="apidoc.element.jszip.NodejsStreamOutputAdapter.prototype._read">
        function <span class="apidocSignatureSpan">jszip.NodejsStreamOutputAdapter.prototype.</span>_read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function () {
    this._helper.resume();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.StreamHelper" id="apidoc.module.jszip.StreamHelper">module jszip.StreamHelper</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.StreamHelper.StreamHelper" id="apidoc.element.jszip.StreamHelper.StreamHelper">
        function <span class="apidocSignatureSpan">jszip.</span>StreamHelper
        <span class="apidocSignatureSpan">(worker, outputType, mimeType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch(outputType) {
        case "blob":
            internalType = "arraybuffer";
        break;
        case "arraybuffer":
            internalType = "uint8array";
        break;
        case "base64":
            internalType = "string";
        break;
    }

    try {
        // the type used internally
        this._internalType = internalType;
        // the type used to output results
        this._outputType = outputType;
        // the mime type
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        // the last workers can be rewired without issues but we need to
        // prevent any updates on previous workers.
        worker.lock();
    } catch(e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.StreamHelper.prototype" id="apidoc.module.jszip.StreamHelper.prototype">module jszip.StreamHelper.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.StreamHelper.prototype.accumulate" id="apidoc.element.jszip.StreamHelper.prototype.accumulate">
        function <span class="apidocSignatureSpan">jszip.StreamHelper.prototype.</span>accumulate
        <span class="apidocSignatureSpan">(updateCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accumulate = function (updateCb) {
    return accumulate(this, updateCb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return new StreamHelper(worker, opts.type || "string", opts.mimeType);
},
/**
 * Generate the complete zip file asynchronously.
 * @see generateInternalStream
 */
generateAsync: function(options, onUpdate) {
    return this.generateInternalStream(options).<span class="apidocCodeKeywordSpan">accumulate</span>(onUpdate);
},
/**
 * Generate the complete zip file asynchronously.
 * @see generateInternalStream
 */
generateNodeStream: function(options, onUpdate) {
    options = options || {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.StreamHelper.prototype.on" id="apidoc.element.jszip.StreamHelper.prototype.on">
        function <span class="apidocSignatureSpan">jszip.StreamHelper.prototype.</span>on
        <span class="apidocSignatureSpan">(evt, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (evt, fn) {
    var self = this;

    if(evt === "data") {
        this._worker.on(evt, function (chunk) {
            fn.call(self, chunk.data, chunk.meta);
        });
    } else {
        this._worker.on(evt, function () {
            utils.delay(fn, arguments, self);
        });
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
getContentWorker : function () {
    var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
    .pipe(this.compression.uncompressWorker())
    .pipe(new DataLengthProbe("data_length"));

    var that = this;
    worker.<span class="apidocCodeKeywordSpan">on</span>("end", function () {
        if(this.streamInfo['data_length'] !== that.uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
        }
    });
    return worker;
},
/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.StreamHelper.prototype.pause" id="apidoc.element.jszip.StreamHelper.prototype.pause">
        function <span class="apidocSignatureSpan">jszip.StreamHelper.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
    this._worker.pause();
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Prepare the next source to be read.
*/
ZipFileWorker.prototype.prepareNextSource = function () {
   this.previous = this._sources.shift();
   this.openedSource(this.previous.streamInfo);
   if (this.isPaused) {
       this.previous.<span class="apidocCodeKeywordSpan">pause</span>();
   } else {
       this.previous.resume();
   }
};

/**
* @see GenericWorker.registerPrevious
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.StreamHelper.prototype.resume" id="apidoc.element.jszip.StreamHelper.prototype.resume">
        function <span class="apidocSignatureSpan">jszip.StreamHelper.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
    utils.delay(this._worker.resume, [], this._worker);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.<span class="apidocCodeKeywordSpan">resume</span>();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.StreamHelper.prototype.toNodejsStream" id="apidoc.element.jszip.StreamHelper.prototype.toNodejsStream">
        function <span class="apidocSignatureSpan">jszip.StreamHelper.prototype.</span>toNodejsStream
        <span class="apidocSignatureSpan">(updateCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNodejsStream = function (updateCb) {
    utils.checkSupport("nodestream");
    if (this._outputType !== "nodebuffer") {
        // an object stream containing blob/arraybuffer/uint8array/string
        // is strange and I don't know if it would be useful.
        // I you find this comment and have a good usecase, please open a
        // bug report !
        throw new Error(this._outputType + " is not supported by this method");
    }

    return new NodejsStreamOutputAdapter(this, {
        objectMode : this._outputType !== "nodebuffer"
    }, updateCb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    * @see generateInternalStream
    */
   generateNodeStream: function(options, onUpdate) {
       options = options || {};
       if (!options.type) {
           options.type = "nodebuffer";
       }
       return this.generateInternalStream(options).<span class="apidocCodeKeywordSpan">toNodejsStream</span>(onUpdate);
   }
};
module.exports = out;

},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter"
;:12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":
31,"./utils":32,"./zipObject":35}],16:[function(require,module,exports){
/*
* This file is used by module bundlers (browserify/webpack/etc) when
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.StringReader" id="apidoc.module.jszip.StringReader">module jszip.StringReader</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.StringReader.StringReader" id="apidoc.element.jszip.StringReader.StringReader">
        function <span class="apidocSignatureSpan">jszip.</span>StringReader
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StringReader(data) {
    DataReader.call(this, data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.StringReader.prototype" id="apidoc.module.jszip.StringReader.prototype">module jszip.StringReader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.StringReader.prototype.byteAt" id="apidoc.element.jszip.StringReader.prototype.byteAt">
        function <span class="apidocSignatureSpan">jszip.StringReader.prototype.</span>byteAt
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">byteAt = function (i) {
    return this.data.charCodeAt(this.zero + i);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {number} the corresponding number.
 */
readInt: function(size) {
    var result = 0,
        i;
    this.checkOffset(size);
    for (i = this.index + size - 1; i &gt;= this.index; i--) {
        result = (result &lt;&lt; 8) + this.<span class="apidocCodeKeywordSpan">byteAt</span>(i);
    }
    this.index += size;
    return result;
},
/**
 * Get the next string with a given byte size.
 * @param {number} size the number of bytes to read.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.StringReader.prototype.lastIndexOfSignature" id="apidoc.element.jszip.StringReader.prototype.lastIndexOfSignature">
        function <span class="apidocSignatureSpan">jszip.StringReader.prototype.</span>lastIndexOfSignature
        <span class="apidocSignatureSpan">(sig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastIndexOfSignature = function (sig) {
    return this.data.lastIndexOf(sig) - this.zero;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }
},
/**
 * Read the end of central directory.
 */
readEndOfCentral: function() {
    var offset = this.reader.<span class="apidocCodeKeywordSpan">lastIndexOfSignature</span>(sig.CENTRAL_DIRECTORY_END);
    if (offset &lt; 0) {
        // Check if the content is a truncated zip or complete garbage.
        // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
        // extractible zip for example) but it can give a good hint.
        // If an ajax request was used without responseType, we will also
        // get unreadable data.
        var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.StringReader.prototype.readAndCheckSignature" id="apidoc.element.jszip.StringReader.prototype.readAndCheckSignature">
        function <span class="apidocSignatureSpan">jszip.StringReader.prototype.</span>readAndCheckSignature
        <span class="apidocSignatureSpan">(sig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readAndCheckSignature = function (sig) {
    var data = this.readData(4);
    return sig === data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ZipEntries.prototype = {
/**
 * Check that the reader is on the speficied signature.
 * @param {string} expectedSignature the expected signature.
 * @throws {Error} if it is an other signature.
 */
checkSignature: function(expectedSignature) {
    if (!this.reader.<span class="apidocCodeKeywordSpan">readAndCheckSignature</span>(expectedSignature)) {
        this.reader.index -= 4;
        var signature = this.reader.readString(4);
        throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + "
;, expected " + utils.pretty(expectedSignature) + ")");
    }
},
/**
 * Check if the given signature is at the given index.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.StringReader.prototype.readData" id="apidoc.element.jszip.StringReader.prototype.readData">
        function <span class="apidocSignatureSpan">jszip.StringReader.prototype.</span>readData
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readData = function (size) {
    this.checkOffset(size);
    // this will work because the constructor applied the "&amp; 0xff" mask.
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
var sig0 = sig.charCodeAt(0),
    sig1 = sig.charCodeAt(1),
    sig2 = sig.charCodeAt(2),
    sig3 = sig.charCodeAt(3),
    data = this.<span class="apidocCodeKeywordSpan">readData</span>(4);
return sig0 === data[0] &amp;&amp; sig1 === data[1] &amp;&amp; sig2 === data[2] &amp;&amp; sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function(size) {
this.checkOffset(size);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.Uint8ArrayReader" id="apidoc.module.jszip.Uint8ArrayReader">module jszip.Uint8ArrayReader</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.Uint8ArrayReader.Uint8ArrayReader" id="apidoc.element.jszip.Uint8ArrayReader.Uint8ArrayReader">
        function <span class="apidocSignatureSpan">jszip.</span>Uint8ArrayReader
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.Uint8ArrayReader.prototype" id="apidoc.module.jszip.Uint8ArrayReader.prototype">module jszip.Uint8ArrayReader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.Uint8ArrayReader.prototype.readData" id="apidoc.element.jszip.Uint8ArrayReader.prototype.readData">
        function <span class="apidocSignatureSpan">jszip.Uint8ArrayReader.prototype.</span>readData
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readData = function (size) {
    this.checkOffset(size);
    if(size === 0) {
        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
        return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
var sig0 = sig.charCodeAt(0),
    sig1 = sig.charCodeAt(1),
    sig2 = sig.charCodeAt(2),
    sig3 = sig.charCodeAt(3),
    data = this.<span class="apidocCodeKeywordSpan">readData</span>(4);
return sig0 === data[0] &amp;&amp; sig1 === data[1] &amp;&amp; sig2 === data[2] &amp;&amp; sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function(size) {
this.checkOffset(size);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.ZipFileWorker" id="apidoc.module.jszip.ZipFileWorker">module jszip.ZipFileWorker</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.ZipFileWorker.ZipFileWorker" id="apidoc.element.jszip.ZipFileWorker.ZipFileWorker">
        function <span class="apidocSignatureSpan">jszip.</span>ZipFileWorker
        <span class="apidocSignatureSpan">(streamFiles, comment, platform, encodeFileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    // The number of bytes written so far. This doesn't count accumulated chunks.
    this.bytesWritten = 0;
    // The comment of the zip file
    this.zipComment = comment;
    // The platform "generating" the zip file.
    this.zipPlatform = platform;
    // the function to encode file names and comments.
    this.encodeFileName = encodeFileName;
    // Should we stream the content of the files ?
    this.streamFiles = streamFiles;
    // If `streamFiles` is false, we will need to accumulate the content of the
    // files to calculate sizes / crc32 (and write them *before* the content).
    // This boolean indicates if we are accumulating chunks (it will change a lot
    // during the lifetime of this worker).
    this.accumulate = false;
    // The buffer receiving chunks when accumulating content.
    this.contentBuffer = [];
    // The list of generated directory records.
    this.dirRecords = [];
    // The offset (in bytes) from the beginning of the zip file for the current source.
    this.currentSourceOffset = 0;
    // The total number of entries in this zip file.
    this.entriesCount = 0;
    // the name of the file currently being added, null when handling the end of the zip file.
    // Used for the emited metadata.
    this.currentFile = null;



    this._sources = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.ZipFileWorker.prototype" id="apidoc.module.jszip.ZipFileWorker.prototype">module jszip.ZipFileWorker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.ZipFileWorker.prototype.closedSource" id="apidoc.element.jszip.ZipFileWorker.prototype.closedSource">
        function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>closedSource
        <span class="apidocSignatureSpan">(streamInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closedSource = function (streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles &amp;&amp; !streamInfo['file'].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName
);

    this.dirRecords.push(record.dirRecord);
    if(streamedContent) {
        // after the streamed file, we put data descriptors
        this.push({
            data : generateDataDescriptors(streamInfo),
            meta : {percent:100}
        });
    } else {
        // the content wasn't streamed, we need to push everything now
        // first the file record, then the content
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
        while(this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
        }
    }
    this.currentFile = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._sources.push(previous);
var self = this;

previous.on('data', function (chunk) {
    self.processChunk(chunk);
});
previous.on('end', function () {
    self.<span class="apidocCodeKeywordSpan">closedSource</span>(self.previous.streamInfo);
    if(self._sources.length) {
        self.prepareNextSource();
    } else {
        self.end();
    }
});
previous.on('error', function (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ZipFileWorker.prototype.error" id="apidoc.element.jszip.ZipFileWorker.prototype.error">
        function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>error
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (e) {
    var sources = this._sources;
    if(!GenericWorker.prototype.error.call(this, e)) {
        return false;
    }
    for(var i = 0; i &lt; sources.length; i++) {
        try {
            sources[i].error(e);
        } catch(e) {
            // the `error` exploded, nothing to do
        }
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       if(self._sources.length) {
           self.prepareNextSource();
       } else {
           self.end();
       }
   });
   previous.on('error', function (e) {
       self.<span class="apidocCodeKeywordSpan">error</span>(e);
   });
   return this;
};

/**
* @see GenericWorker.resume
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ZipFileWorker.prototype.flush" id="apidoc.element.jszip.ZipFileWorker.prototype.flush">
        function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {

    var localDirLength = this.bytesWritten;
    for(var i = 0; i &lt; this.dirRecords.length; i++) {
        this.push({
            data : this.dirRecords[i],
            meta : {percent:100}
        });
    }
    var centralDirLength = this.bytesWritten - localDirLength;

    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName
);

    this.push({
        data : dirEnd,
        meta : {percent:100}
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end : function () {
if (this.isFinished) {
    return false;
}

this.<span class="apidocCodeKeywordSpan">flush</span>();
try {
    this.emit("end");
    this.cleanUp();
    this.isFinished = true;
} catch (e) {
    this.emit("error", e);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ZipFileWorker.prototype.lock" id="apidoc.element.jszip.ZipFileWorker.prototype.lock">
        function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>lock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for(var i = 0; i &lt; sources.length; i++) {
        sources[i].lock();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * @see GenericWorker.lock
 */
ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for(var i = 0; i &lt; sources.length; i++) {
        sources[i].<span class="apidocCodeKeywordSpan">lock</span>();
    }
};

module.exports = ZipFileWorker;

},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils
":32}],9:[function(require,module,exports){
'use strict';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ZipFileWorker.prototype.openedSource" id="apidoc.element.jszip.ZipFileWorker.prototype.openedSource">
        function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>openedSource
        <span class="apidocSignatureSpan">(streamInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openedSource = function (streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo['file'].name;

    var streamedContent = this.streamFiles &amp;&amp; !streamInfo['file'].dir;

    // don't stream folders (because they don't have any content)
    if(streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName
);
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
    } else {
        // we need to wait for the whole file before pushing anything
        this.accumulate = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Prepare the next source to be read.
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.<span class="apidocCodeKeywordSpan">openedSource</span>(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.resume();
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ZipFileWorker.prototype.prepareNextSource" id="apidoc.element.jszip.ZipFileWorker.prototype.prepareNextSource">
        function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>prepareNextSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.resume();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

previous.on('data', function (chunk) {
    self.processChunk(chunk);
});
previous.on('end', function () {
    self.closedSource(self.previous.streamInfo);
    if(self._sources.length) {
        self.<span class="apidocCodeKeywordSpan">prepareNextSource</span>();
    } else {
        self.end();
    }
});
previous.on('error', function (e) {
    self.error(e);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ZipFileWorker.prototype.push" id="apidoc.element.jszip.ZipFileWorker.prototype.push">
        function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>push
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (chunk) {

    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;

    if(this.accumulate) {
        this.contentBuffer.push(chunk);
    } else {
        this.bytesWritten += chunk.data.length;

        GenericWorker.prototype.push.call(this, {
            data : chunk.data,
            meta : {
                currentFile : this.currentFile,
                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        enc1 = chr1 &gt;&gt; 2;
        enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4);
        enc3 = remainingBytes &gt; 1 ? (((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6)) : 64;
        enc4 = remainingBytes &gt; 2 ? (chr3 &amp; 63) : 64;

        output.<span class="apidocCodeKeywordSpan">push</span>(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3
) + _keyStr.charAt(enc4));

    }

    return output.join("");
};

// public method for decoding
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ZipFileWorker.prototype.registerPrevious" id="apidoc.element.jszip.ZipFileWorker.prototype.registerPrevious">
        function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>registerPrevious
        <span class="apidocSignatureSpan">(previous)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerPrevious = function (previous) {
    this._sources.push(previous);
    var self = this;

    previous.on('data', function (chunk) {
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.closedSource(self.previous.streamInfo);
        if(self._sources.length) {
            self.prepareNextSource();
        } else {
            self.end();
        }
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},
/**
 * Chain a worker with an other.
 * @param {Worker} next the worker receiving events from the current one.
 * @return {worker} the next worker for chainability
 */
pipe : function (next) {
    return next.<span class="apidocCodeKeywordSpan">registerPrevious</span>(this);
},
/**
 * Same as `pipe` in the other direction.
 * Using an API with `pipe(next)` is very easy.
 * Implementing the API with the point of view of the next one registering
 * a source is easier, see the ZipFileWorker.
 * @param {Worker} previous the previous worker, sending events to this one
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.ZipFileWorker.prototype.resume" id="apidoc.element.jszip.ZipFileWorker.prototype.resume">
        function <span class="apidocSignatureSpan">jszip.ZipFileWorker.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this.previous &amp;&amp; this._sources.length) {
        this.prepareNextSource();
        return true;
    }
    if (!this.previous &amp;&amp; !this._sources.length &amp;&amp; !this.generatedError) {
        this.end();
        return true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.<span class="apidocCodeKeywordSpan">resume</span>();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.base64" id="apidoc.module.jszip.base64">module jszip.base64</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.base64.decode" id="apidoc.element.jszip.base64.decode">
        function <span class="apidocSignatureSpan">jszip.base64.</span>decode
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;

    var dataUrlPrefix = "data:";

    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        // This is a common error: people give a data url
        // (data:image/png;base64,iVBOR...) with a {base64: true} and
        // wonders why things don't work.
        // We can detect that the string input looks like a data url but we
        // *can't* be sure it is one: removing everything up to the comma would
        // be too dangerous.
        throw new Error("Invalid base64 input, it looks like a data url.");
    }

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    var totalLength = input.length * 3 / 4;
    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (totalLength % 1 !== 0) {
        // totalLength is not an integer, the length does not match a valid
        // base64 content. That can happen if:
        // - the input is not a base64 content
        // - the input is *almost* a base64 content, with a extra chars at the
        //   beginning or at the end
        // - the input uses a base64 variant (base64url for example)
        throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
        output = new Uint8Array(totalLength|0);
    } else {
        output = new Array(totalLength|0);
    }

    while (i &lt; input.length) {

        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4);
        chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2);
        chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4;

        output[resultIndex++] = chr1;

        if (enc3 !== 64) {
            output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
            output[resultIndex++] = chr3;
        }

    }

    return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    );
}
// special case : it's way easier to work with Uint8Array than with ArrayBuffer
if (dataType === "arraybuffer") {
    data = exports.transformTo("uint8array", data);
} else if (dataType === "string") {
    if (isBase64) {
        data = base64.<span class="apidocCodeKeywordSpan">decode</span>(data);
    }
    else if (isBinary) {
        // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
        if (isOptimizedBinaryString !== true) {
            // this is a string, not in a base64 format.
            // Be sure that this is a correct "binary string"
            data = string2binary(data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.base64.encode" id="apidoc.element.jszip.base64.encode">
        function <span class="apidocSignatureSpan">jszip.base64.</span>encode
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;

    var isArray = utils.getTypeOf(input) !== "string";
    while (i &lt; input.length) {
        remainingBytes = len - i;

        if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i &lt; len ? input.charCodeAt(i++) : 0;
            chr3 = i &lt; len ? input.charCodeAt(i++) : 0;
        } else {
            chr1 = input[i++];
            chr2 = i &lt; len ? input[i++] : 0;
            chr3 = i &lt; len ? input[i++] : 0;
        }

        enc1 = chr1 &gt;&gt; 2;
        enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4);
        enc3 = remainingBytes &gt; 1 ? (((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6)) : 64;
        enc4 = remainingBytes &gt; 2 ? (chr3 &amp; 63) : 64;

        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));

    }

    return output.join("");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function transformZipOutput(resultType, chunkType, dataArray, mimeType) {
    var content = null;
    switch(resultType) {
        case "blob" :
            return utils.newBlob(dataArray, mimeType);
        case "base64" :
            content = concat(chunkType, dataArray);
            return base64.<span class="apidocCodeKeywordSpan">encode</span>(content);
        default :
            content = concat(chunkType, dataArray);
            return utils.transformTo(resultType, content);
    }
}

/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.compressedObject" id="apidoc.module.jszip.compressedObject">module jszip.compressedObject</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.compressedObject.compressedObject" id="apidoc.element.jszip.compressedObject.compressedObject">
        function <span class="apidocSignatureSpan">jszip.</span>compressedObject
        <span class="apidocSignatureSpan">(compressedSize, uncompressedSize, crc32, compression, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.compressedObject.createWorkerFrom" id="apidoc.element.jszip.compressedObject.createWorkerFrom">
        function <span class="apidocSignatureSpan">jszip.compressedObject.</span>createWorkerFrom
        <span class="apidocSignatureSpan">(uncompressedWorker, compression, compressionOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker
    .pipe(new Crc32Probe())
    .pipe(new DataLengthProbe("uncompressedSize"))
    .pipe(compression.compressWorker(compressionOptions))
    .pipe(new DataLengthProbe("compressedSize"))
    .withStreamInfo("compression", compression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ) {
        return this._data.getCompressedWorker();
    } else {
        var result = this._decompressWorker();
        if(!this._dataBinary) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
        }
        return CompressedObject.<span class="apidocCodeKeywordSpan">createWorkerFrom</span>(result, compression, compressionOptions
);
    }
},
/**
 * Return a worker for the decompressed content.
 * @private
 * @return Worker the worker.
 */
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.compressedObject.prototype" id="apidoc.module.jszip.compressedObject.prototype">module jszip.compressedObject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.compressedObject.prototype.getCompressedWorker" id="apidoc.element.jszip.compressedObject.prototype.getCompressedWorker">
        function <span class="apidocSignatureSpan">jszip.compressedObject.prototype.</span>getCompressedWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCompressedWorker = function () {
    return new DataWorker(external.Promise.resolve(this.compressedContent))
    .withStreamInfo("compressedSize", this.compressedSize)
    .withStreamInfo("uncompressedSize", this.uncompressedSize)
    .withStreamInfo("crc32", this.crc32)
    .withStreamInfo("compression", this.compression)
    ;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return Worker the worker.
 */
_compressWorker: function (compression, compressionOptions) {
    if (
        this._data instanceof CompressedObject &amp;&amp;
        this._data.compression.magic === compression.magic
    ) {
        return this._data.<span class="apidocCodeKeywordSpan">getCompressedWorker</span>();
    } else {
        var result = this._decompressWorker();
        if(!this._dataBinary) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
        }
        return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.compressedObject.prototype.getContentWorker" id="apidoc.element.jszip.compressedObject.prototype.getContentWorker">
        function <span class="apidocSignatureSpan">jszip.compressedObject.prototype.</span>getContentWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContentWorker = function () {
    var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
    .pipe(this.compression.uncompressWorker())
    .pipe(new DataLengthProbe("data_length"));

    var that = this;
    worker.on("end", function () {
        if(this.streamInfo['data_length'] !== that.uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
        }
    });
    return worker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
return new external.Promise(function (resolve, reject) {
    var worker = zipEntry.decompressed.<span class="apidocCodeKeywordSpan">getContentWorker</span>().pipe(new Crc32Probe());
    worker.on("error", function (e) {
        reject(e);
    })
    .on("end", function () {
        if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
            reject(new Error("Corrupted zip : CRC32 mismatch"));
        } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.external" id="apidoc.module.jszip.external">module jszip.external</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.external.Promise" id="apidoc.element.jszip.external.Promise">
        function <span class="apidocSignatureSpan">jszip.external.</span>Promise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
return new external.<span class="apidocCodeKeywordSpan">Promise</span>(function (resolve, reject) {
    var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
    worker.on("error", function (e) {
        reject(e);
    })
    .on("end", function () {
        if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
            reject(new Error("Corrupted zip : CRC32 mismatch"));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.flate" id="apidoc.module.jszip.flate">module jszip.flate</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.flate.compressWorker" id="apidoc.element.jszip.flate.compressWorker">
        function <span class="apidocSignatureSpan">jszip.flate.</span>compressWorker
        <span class="apidocSignatureSpan">(compressionOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */
CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker
    .pipe(new Crc32Probe())
    .pipe(new DataLengthProbe("uncompressedSize"))
    .pipe(compression.<span class="apidocCodeKeywordSpan">compressWorker</span>(compressionOptions))
    .pipe(new DataLengthProbe("compressedSize"))
    .withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker
":27}],3:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.flate.uncompressWorker" id="apidoc.element.jszip.flate.uncompressWorker">
        function <span class="apidocSignatureSpan">jszip.flate.</span>uncompressWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker : function () {
var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
.pipe(this.compression.<span class="apidocCodeKeywordSpan">uncompressWorker</span>())
.pipe(new DataLengthProbe("data_length"));

var that = this;
worker.on("end", function () {
    if(this.streamInfo['data_length'] !== that.uncompressedSize) {
        throw new Error("Bug : uncompressed data size mismatch");
    }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.index" id="apidoc.module.jszip.index">module jszip.index</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.index.generateWorker" id="apidoc.element.jszip.index.generateWorker">
        function <span class="apidocSignatureSpan">jszip.index.</span>generateWorker
        <span class="apidocSignatureSpan">(zip, options, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateWorker = function (zip, options, comment) {

    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {

        zip.forEach(function (relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir, date = file.date;

            file._compressWorker(compression, compressionOptions)
            .withStreamInfo("file", {
                name : relativePath,
                dir : dir,
                date : date,
                comment : file.comment || "",
                unixPermissions : file.unixPermissions,
                dosPermissions : file.dosPermissions
            })
            .pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
        zipFileWorker.error(e);
    }

    return zipFileWorker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          opts.platform = "UNIX";
      }
      if (opts.platform === 'win32') {
          opts.platform = "DOS";
      }

      var comment = opts.comment || this.comment || "";
      worker = generate.<span class="apidocCodeKeywordSpan">generateWorker</span>(this, opts, comment);
  } catch (e) {
    worker = new GenericWorker("error");
    worker.error(e);
  }
  return new StreamHelper(worker, opts.type || "string", opts.mimeType);
},
/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.nodejsUtils" id="apidoc.module.jszip.nodejsUtils">module jszip.nodejsUtils</a></h1>




    <h2>
        <a href="#apidoc.element.jszip.nodejsUtils.isBuffer" id="apidoc.element.jszip.nodejsUtils.isBuffer">
        function <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>isBuffer
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBuffer = function (b){
    return Buffer.isBuffer(b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},
/**
 * Find out if an object is a Buffer.
 * @param {Object} b the object to test.
 * @return {Boolean} true if the object is a Buffer, false otherwise.
 */
isBuffer : function(b){
    return Buffer.<span class="apidocCodeKeywordSpan">isBuffer</span>(b);
},

isStream : function (obj) {
    return obj &amp;&amp;
        typeof obj.on === "function" &amp;&amp;
        typeof obj.pause === "function" &amp;&amp;
        typeof obj.resume === "function";
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.nodejsUtils.isStream" id="apidoc.element.jszip.nodejsUtils.isStream">
        function <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>isStream
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStream = function (obj) {
    return obj &amp;&amp;
        typeof obj.on === "function" &amp;&amp;
        typeof obj.pause === "function" &amp;&amp;
        typeof obj.resume === "function";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    base64: false,
    checkCRC32: false,
    optimizedBinaryString: false,
    createFolders: false,
    decodeFileName: utf8.utf8decode
});

if (nodejsUtils.isNode &amp;&amp; nodejsUtils.<span class="apidocCodeKeywordSpan">isStream</span>(data)) {
    return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
}

return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
.then(function(data) {
    var zipEntries = new ZipEntries(options);
    zipEntries.load(data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.nodejsUtils.newBuffer" id="apidoc.element.jszip.nodejsUtils.newBuffer">
        function <span class="apidocSignatureSpan">jszip.nodejsUtils.</span>newBuffer
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newBuffer = function (data, encoding){
    return new Buffer(data, encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.<span class="apidocCodeKeywordSpan">newBuffer</span>(str, "utf-8");
    }

    return string2buf(str);
};


/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.object" id="apidoc.module.jszip.object">module jszip.object</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.object.file" id="apidoc.element.jszip.object.file">
        function <span class="apidocSignatureSpan">jszip.object.</span>file
        <span class="apidocSignatureSpan">(name, data, o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file = function (name, data, o) {
    if (arguments.length === 1) {
        if (isRegExp(name)) {
            var regexp = name;
            return this.filter(function(relativePath, file) {
                return !file.dir &amp;&amp; regexp.test(relativePath);
            });
        }
        else { // text
            var obj = this.files[this.root + name];
            if (obj &amp;&amp; !obj.dir) {
                return obj;
            } else {
                return null;
            }
        }
    }
    else { // more than one argument : we have data !
        name = this.root + name;
        fileAdd.call(this, name, data, o);
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- rename variable: 'byte' is a reserved word (see [#76](https://github.com/Stuk/jszip/pull/76))
- add support for the unicode path extra field (see [#82](https://github.com/Stuk/jszip/pull/82))
- ensure that the generated files have a header with the licenses (see [#80](https://github.com/Stuk/jszip/pull/80))

# v2.0.0, 2013-10-20

- `JSZipBase64` has been renamed to `JSZip.base64`.
- The `data` attribute on the object returned by `zip.<span class="apidocCodeKeywordSpan">file</span>(name)` has been removed. Use
 `asText()`, `asBinary()`, `asUint8Array()`, `asArrayBuffer()` or `asNodeBuffer()`.

- [Fix issue with Android browser](https://github.com/Stuk/jszip/pull/60)

- The compression/decompression methods now give their input type with the `compressInputType` and `uncompressInputType` attributes
.
- Lazily decompress data when needed and [improve performance in general](https://github.com/Stuk/jszip/pull/56)
- [Add support for `Buffer` in Node.js](https://github.com/Stuk/jszip/pull/57).
- Package for CommonJS/npm.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.object.filter" id="apidoc.element.jszip.object.filter">
        function <span class="apidocSignatureSpan">jszip.object.</span>filter
        <span class="apidocSignatureSpan">(search)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (search) {
    var result = [];
    this.forEach(function (relativePath, entry) {
        if (search(relativePath, entry)) { // the file matches the function
            result.push(entry);
        }

    });
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
 * a file (when searching by string) or an array of files (when searching by regex).
 */
file: function(name, data, o) {
    if (arguments.length === 1) {
        if (isRegExp(name)) {
            var regexp = name;
            return this.<span class="apidocCodeKeywordSpan">filter</span>(function(relativePath, file) {
                return !file.dir &amp;&amp; regexp.test(relativePath);
            });
        }
        else { // text
            var obj = this.files[this.root + name];
            if (obj &amp;&amp; !obj.dir) {
                return obj;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.object.folder" id="apidoc.element.jszip.object.folder">
        function <span class="apidocSignatureSpan">jszip.object.</span>folder
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">folder = function (arg) {
    if (!arg) {
        return this;
    }

    if (isRegExp(arg)) {
        return this.filter(function(relativePath, file) {
            return file.dir &amp;&amp; arg.test(relativePath);
        });
    }

    // else, name is a new folder
    var name = this.root + arg;
    var newFolder = folderAdd.call(this, name);

    // Allow chaining by returning a new object with this folder as the root
    var ret = this.clone();
    ret.root = newFolder.name;
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
See https://stuk.github.io/jszip for all the documentation.

```javascript
var zip = new JSZip();

zip.file("Hello.txt", "Hello World\n");

var img = zip.<span class="apidocCodeKeywordSpan">folder</span>("images");
img.file("smile.gif", imgData, {base64: true});

zip.generateAsync({type:"blob"}).then(function(content) {
    // see FileSaver.js
    saveAs(content, "example.zip");
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.object.forEach" id="apidoc.element.jszip.object.forEach">
        function <span class="apidocSignatureSpan">jszip.object.</span>forEach
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (cb) {
    var filename, relativePath, file;
    for (filename in this.files) {
        if (!this.files.hasOwnProperty(filename)) {
            continue;
        }
        file = this.files[filename];
        relativePath = filename.slice(this.root.length, filename.length);
        if (relativePath &amp;&amp; filename.slice(0, this.root.length) === this.root) { // the file is in the current root
            cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
exports.generateWorker = function (zip, options, comment) {

    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {

        zip.<span class="apidocCodeKeywordSpan">forEach</span>(function (relativePath, file) {
entriesCount++;
var compression = getCompression(file.options.compression, options.compression);
var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
var dir = file.dir, date = file.date;

file._compressWorker(compression, compressionOptions)
.withStreamInfo("file", {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.object.generate" id="apidoc.element.jszip.object.generate">
        function <span class="apidocSignatureSpan">jszip.object.</span>generate
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (options) {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.object.generateAsync" id="apidoc.element.jszip.object.generateAsync">
        function <span class="apidocSignatureSpan">jszip.object.</span>generateAsync
        <span class="apidocSignatureSpan">(options, onUpdate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateAsync = function (options, onUpdate) {
    return this.generateInternalStream(options).accumulate(onUpdate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var zip = new JSZip();

zip.file("Hello.txt", "Hello World\n");

var img = zip.folder("images");
img.file("smile.gif", imgData, {base64: true});

zip.<span class="apidocCodeKeywordSpan">generateAsync</span>({type:"blob"}).then(function(content) {
    // see FileSaver.js
    saveAs(content, "example.zip");
});

/*
Results in a zip containing
Hello.txt
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.object.generateInternalStream" id="apidoc.element.jszip.object.generateInternalStream">
        function <span class="apidocSignatureSpan">jszip.object.</span>generateInternalStream
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateInternalStream = function (options) {
  var worker, opts = {};
  try {
      opts = utils.extend(options || {}, {
          streamFiles: false,
          compression: "STORE",
          compressionOptions : null,
          type: "",
          platform: "DOS",
          comment: null,
          mimeType: 'application/zip',
          encodeFileName: utf8.utf8encode
      });

      opts.type = opts.type.toLowerCase();
      opts.compression = opts.compression.toUpperCase();

      // "binarystring" is prefered but the internals use "string".
      if(opts.type === "binarystring") {
        opts.type = "string";
      }

      if (!opts.type) {
        throw new Error("No output type specified.");
      }

      utils.checkSupport(opts.type);

      // accept nodejs `process.platform`
      if(
          opts.platform === 'darwin' ||
          opts.platform === 'freebsd' ||
          opts.platform === 'linux' ||
          opts.platform === 'sunos'
      ) {
          opts.platform = "UNIX";
      }
      if (opts.platform === 'win32') {
          opts.platform = "DOS";
      }

      var comment = opts.comment || this.comment || "";
      worker = generate.generateWorker(this, opts, comment);
  } catch (e) {
    worker = new GenericWorker("error");
    worker.error(e);
  }
  return new StreamHelper(worker, opts.type || "string", opts.mimeType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return new StreamHelper(worker, opts.type || "string", opts.mimeType);
},
/**
 * Generate the complete zip file asynchronously.
 * @see generateInternalStream
 */
generateAsync: function(options, onUpdate) {
    return this.<span class="apidocCodeKeywordSpan">generateInternalStream</span>(options).accumulate(onUpdate);
},
/**
 * Generate the complete zip file asynchronously.
 * @see generateInternalStream
 */
generateNodeStream: function(options, onUpdate) {
    options = options || {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.object.generateNodeStream" id="apidoc.element.jszip.object.generateNodeStream">
        function <span class="apidocSignatureSpan">jszip.object.</span>generateNodeStream
        <span class="apidocSignatureSpan">(options, onUpdate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateNodeStream = function (options, onUpdate) {
    options = options || {};
    if (!options.type) {
        options.type = "nodebuffer";
    }
    return this.generateInternalStream(options).toNodejsStream(onUpdate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.object.load" id="apidoc.element.jszip.object.load">
        function <span class="apidocSignatureSpan">jszip.object.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (nodejsUtils.isNode &amp;&amp; nodejsUtils.isStream(data)) {
    return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
}

return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
.then(function(data) {
    var zipEntries = new ZipEntries(options);
    zipEntries.<span class="apidocCodeKeywordSpan">load</span>(data);
    return zipEntries;
}).then(function checkCRC32(zipEntries) {
    var promises = [external.Promise.resolve(zipEntries)];
    var files = zipEntries.files;
    if (options.checkCRC32) {
        for (var i = 0; i &lt; files.length; i++) {
            promises.push(checkEntryCRC32(files[i]));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.object.loadAsync" id="apidoc.element.jszip.object.loadAsync">
        function <span class="apidocSignatureSpan">jszip.object.</span>loadAsync
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadAsync = function (data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode &amp;&amp; nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
    .then(function(data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i &lt; files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i &lt; files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment : input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions : input.unixPermissions,
                dosPermissions : input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
JSZip.defaults = require('./defaults');

// TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327
JSZip.version = "3.1.3";

JSZip.loadAsync = function (content, options) {
    return new JSZip().<span class="apidocCodeKeywordSpan">loadAsync</span>(content, options);
};

JSZip.external = require("./external");
module.exports = JSZip;

},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11
:[function(require,module,exports){
'use strict';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.object.remove" id="apidoc.element.jszip.object.remove">
        function <span class="apidocSignatureSpan">jszip.object.</span>remove
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (name) {
    name = this.root + name;
    var file = this.files[name];
    if (!file) {
        // Look for any folders
        if (name.slice(-1) !== "/") {
            name += "/";
        }
        file = this.files[name];
    }

    if (file &amp;&amp; !file.dir) {
        // file
        delete this.files[name];
    } else {
        // maybe a folder, delete recursively
        var kids = this.filter(function(relativePath, file) {
            return file.name.slice(0, name.length) === name;
        });
        for (var i = 0; i &lt; kids.length; i++) {
            delete this.files[kids[i].name];
        }
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.utf8" id="apidoc.module.jszip.utf8">module jszip.utf8</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.utf8.Utf8DecodeWorker" id="apidoc.element.jszip.utf8.Utf8DecodeWorker">
        function <span class="apidocSignatureSpan">jszip.utf8.</span>Utf8DecodeWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    // the last bytes if a chunk didn't end with a complete codepoint.
    this.leftOver = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var isUnicodeString = !this._dataBinary;

    if (isUnicodeString &amp;&amp; !askUnicodeString) {
        result = result.pipe(new utf8.Utf8EncodeWorker());
    }
    if (!isUnicodeString &amp;&amp; askUnicodeString) {
        result = result.pipe(new utf8.<span class="apidocCodeKeywordSpan">Utf8DecodeWorker</span>());
    }

    return new StreamHelper(result, outputType, "");
},

/**
 * Prepare the content in the asked type.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utf8.Utf8EncodeWorker" id="apidoc.element.jszip.utf8.Utf8EncodeWorker">
        function <span class="apidocSignatureSpan">jszip.utf8.</span>Utf8EncodeWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        outputType = "string";
    }
    var result = this._decompressWorker();

    var isUnicodeString = !this._dataBinary;

    if (isUnicodeString &amp;&amp; !askUnicodeString) {
        result = result.pipe(new utf8.<span class="apidocCodeKeywordSpan">Utf8EncodeWorker</span>());
    }
    if (!isUnicodeString &amp;&amp; askUnicodeString) {
        result = result.pipe(new utf8.Utf8DecodeWorker());
    }

    return new StreamHelper(result, outputType, "");
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utf8.utf8decode" id="apidoc.element.jszip.utf8.utf8decode">
        function <span class="apidocSignatureSpan">jszip.utf8.</span>utf8decode
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       } else {
           usableData = data.slice(0, nextBoundary);
           this.leftOver = data.slice(nextBoundary, data.length);
       }
   }

   this.push({
       data : exports.<span class="apidocCodeKeywordSpan">utf8decode</span>(usableData),
       meta : chunk.meta
   });
};

/**
* @see GenericWorker.flush
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utf8.utf8encode" id="apidoc.element.jszip.utf8.utf8encode">
        function <span class="apidocSignatureSpan">jszip.utf8.</span>utf8encode
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.newBuffer(str, "utf-8");
    }

    return string2buf(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Object} the zip parts.
 */
var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
var file = streamInfo['file'],
compression = streamInfo['compression'],
useCustomEncoding = encodeFileName !== utf8.utf8encode,
encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
utfEncodedFileName = utils.transformTo("string", utf8.<span class="apidocCodeKeywordSpan">utf8encode</span>(file.name)),
comment = file.comment,
encodedComment = utils.transformTo("string", encodeFileName(comment)),
utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
useUTF8ForComment = utfEncodedComment.length !== comment.length,
dosTime,
dosDate,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.utils" id="apidoc.module.jszip.utils">module jszip.utils</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.utils.applyFromCharCode" id="apidoc.element.jszip.utils.applyFromCharCode">
        function <span class="apidocSignatureSpan">jszip.utils.</span>applyFromCharCode
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayLikeToString(array) {
    // Performances notes :
    // --------------------
    // String.fromCharCode.apply(null, array) is the fastest, see
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
    // but the stack is limited (and we can get huge arrays !).
    //
    // result += String.fromCharCode(array[i]); generate too many strings !
    //
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
    // TODO : we now have workers that split the work. Do we still need that ?
    var chunk = 65536,
        type = exports.getTypeOf(array),
        canUseApply = true;
    if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }

    if (canUseApply) {
        while (chunk &gt; 1) {
            try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
                chunk = Math.floor(chunk / 2);
            }
        }
    }

    // no apply or chunk error : slow and painful algorithm
    // default browser on android 4.*
    return arrayToStringHelper.stringifyByChar(array);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            utf16buf = utf16buf.subarray(0, out);
        } else {
            utf16buf.length = out;
        }
    }

    // return String.fromCharCode.apply(null, utf16buf);
    return utils.<span class="apidocCodeKeywordSpan">applyFromCharCode</span>(utf16buf);
};


// That's all for the pako functions.


/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.checkSupport" id="apidoc.element.jszip.utils.checkSupport">
        function <span class="apidocSignatureSpan">jszip.utils.</span>checkSupport
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkSupport = function (type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
        throw new Error(type + " is not supported by this platform");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  opts.type = "string";
}

if (!opts.type) {
  throw new Error("No output type specified.");
}

utils.<span class="apidocCodeKeywordSpan">checkSupport</span>(opts.type);

// accept nodejs `process.platform`
if(
    opts.platform === 'darwin' ||
    opts.platform === 'freebsd' ||
    opts.platform === 'linux' ||
    opts.platform === 'sunos'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.delay" id="apidoc.element.jszip.utils.delay">
        function <span class="apidocSignatureSpan">jszip.utils.</span>delay
        <span class="apidocSignatureSpan">(callback, args, self)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delay = function (callback, args, self) {
    setImmediate(function () {
        callback.apply(self || null, args || []);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
DataWorker.prototype.resume = function () {
   if(!GenericWorker.prototype.resume.call(this)) {
       return false;
   }

   if (!this._tickScheduled &amp;&amp; this.dataIsReady) {
       this._tickScheduled = true;
       utils.<span class="apidocCodeKeywordSpan">delay</span>(this._tickAndRepeat, [], this);
   }
   return true;
};

/**
* Trigger a tick a schedule an other call to this function.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.extend" id="apidoc.element.jszip.utils.extend">
        function <span class="apidocSignatureSpan">jszip.utils.</span>extend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function () {
    var result = {}, i, attr;
    for (i = 0; i &lt; arguments.length; i++) { // arguments is not enumerable in some browsers
        for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) &amp;&amp; typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
            }
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    })
    .resume();
});
}

module.exports = function(data, options) {
var zip = this;
options = utils.<span class="apidocCodeKeywordSpan">extend</span>(options || {}, {
    base64: false,
    checkCRC32: false,
    optimizedBinaryString: false,
    createFolders: false,
    decodeFileName: utf8.utf8decode
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.getTypeOf" id="apidoc.element.jszip.utils.getTypeOf">
        function <span class="apidocSignatureSpan">jszip.utils.</span>getTypeOf
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTypeOf = function (input) {
    if (typeof input === "string") {
        return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
    }
    if (support.nodebuffer &amp;&amp; nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
    }
    if (support.uint8array &amp;&amp; input instanceof Uint8Array) {
        return "uint8array";
    }
    if (support.arraybuffer &amp;&amp; input instanceof ArrayBuffer) {
        return "arraybuffer";
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// public method for encoding
exports.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;

    var isArray = utils.<span class="apidocCodeKeywordSpan">getTypeOf</span>(input) !== "string";
    while (i &lt; input.length) {
remainingBytes = len - i;

if (!isArray) {
    chr1 = input.charCodeAt(i++);
    chr2 = i &lt; len ? input.charCodeAt(i++) : 0;
    chr3 = i &lt; len ? input.charCodeAt(i++) : 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.inherits" id="apidoc.element.jszip.utils.inherits">
        function <span class="apidocSignatureSpan">jszip.utils.</span>inherits
        <span class="apidocSignatureSpan">(ctor, superCtor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherits = function (ctor, superCtor) {
    var Obj = function() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self.push({
        data : data,
        meta : self.meta
    });
};
}

utils.<span class="apidocCodeKeywordSpan">inherits</span>(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
this.meta = chunk.meta;
this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.newBlob" id="apidoc.element.jszip.utils.newBlob">
        function <span class="apidocSignatureSpan">jszip.utils.</span>newBlob
        <span class="apidocSignatureSpan">(parts, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newBlob = function (parts, type) {
    exports.checkSupport("blob");

    try {
        // Blob constructor
        return new Blob(parts, {
            type: type
        });
    }
    catch (e) {

        try {
            // deprecated, browser only, old way
            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var builder = new Builder();
            for (var i = 0; i &lt; parts.length; i++) {
                builder.append(parts[i]);
            }
            return builder.getBlob(type);
        }
        catch (e) {

            // well, fuck ?!
            throw new Error("Bug : can't construct the Blob.");
        }
    }


}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */
function transformZipOutput(resultType, chunkType, dataArray, mimeType) {
var content = null;
switch(resultType) {
    case "blob" :
        return utils.<span class="apidocCodeKeywordSpan">newBlob</span>(dataArray, mimeType);
    case "base64" :
        content = concat(chunkType, dataArray);
        return base64.encode(content);
    default :
        content = concat(chunkType, dataArray);
        return utils.transformTo(resultType, content);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.prepareContent" id="apidoc.element.jszip.utils.prepareContent">
        function <span class="apidocSignatureSpan">jszip.utils.</span>prepareContent
        <span class="apidocSignatureSpan">(name, inputData, isBinary, isOptimizedBinaryString, isBase64)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

    // if inputData is already a promise, this flatten it.
    var promise = external.Promise.resolve(inputData).then(function(data) {


        var isBlob = support.blob &amp;&amp; (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString
.call(data)) !== -1);

        if (isBlob &amp;&amp; typeof FileReader !== "undefined") {
            return new external.Promise(function (resolve, reject) {
                var reader = new FileReader();

                reader.onload = function(e) {
                    resolve(e.target.result);
                };
                reader.onerror = function(e) {
                    reject(e.target.error);
                };
                reader.readAsArrayBuffer(data);
            });
        } else {
            return data;
        }
    });

    return promise.then(function(data) {
        var dataType = exports.getTypeOf(data);

        if (!dataType) {
            return external.Promise.reject(
                new Error("The data of '" + name + "' is in an unsupported format !")
            );
        }
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
        if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
            if (isBase64) {
                data = base64.decode(data);
            }
            else if (isBinary) {
                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                }
            }
        }
        return data;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    decodeFileName: utf8.utf8decode
});

if (nodejsUtils.isNode &amp;&amp; nodejsUtils.isStream(data)) {
    return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
}

return utils.<span class="apidocCodeKeywordSpan">prepareContent</span>("the loaded zip file", data, true, options.optimizedBinaryString
, options.base64)
.then(function(data) {
    var zipEntries = new ZipEntries(options);
    zipEntries.load(data);
    return zipEntries;
}).then(function checkCRC32(zipEntries) {
    var promises = [external.Promise.resolve(zipEntries)];
    var files = zipEntries.files;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.pretty" id="apidoc.element.jszip.utils.pretty">
        function <span class="apidocSignatureSpan">jszip.utils.</span>pretty
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pretty = function (str) {
    var res = '',
        code, i;
    for (i = 0; i &lt; (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code &lt; 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} expectedSignature the expected signature.
 * @throws {Error} if it is an other signature.
 */
checkSignature: function(expectedSignature) {
    if (!this.reader.readAndCheckSignature(expectedSignature)) {
        this.reader.index -= 4;
        var signature = this.reader.readString(4);
        throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.<span class="apidocCodeKeywordSpan
">pretty</span>(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
    }
},
/**
 * Check if the given signature is at the given index.
 * @param {number} askedIndex the index to check.
 * @param {string} expectedSignature the signature to expect.
 * @return {boolean} true if the signature is here, false otherwise.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.utils.transformTo" id="apidoc.element.jszip.utils.transformTo">
        function <span class="apidocSignatureSpan">jszip.utils.</span>transformTo
        <span class="apidocSignatureSpan">(outputType, input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transformTo = function (outputType, input) {
    if (!input) {
        // undefined, null, etc
        // an empty string won't harm.
        input = "";
    }
    if (!outputType) {
        return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
utils.inherits(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
this.meta = chunk.meta;
this._pako.push(utils.<span class="apidocCodeKeywordSpan">transformTo</span>(ARRAY_TYPE, chunk.data), false);
};

/**
 * @see GenericWorker.flush
 */
FlateWorker.prototype.flush = function () {
GenericWorker.prototype.flush.call(this);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.zipEntries" id="apidoc.module.jszip.zipEntries">module jszip.zipEntries</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.zipEntries.zipEntries" id="apidoc.element.jszip.zipEntries.zipEntries">
        function <span class="apidocSignatureSpan">jszip.</span>zipEntries
        <span class="apidocSignatureSpan">(loadOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.zipEntries.prototype" id="apidoc.module.jszip.zipEntries.prototype">module jszip.zipEntries.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.checkSignature" id="apidoc.element.jszip.zipEntries.prototype.checkSignature">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>checkSignature
        <span class="apidocSignatureSpan">(expectedSignature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkSignature = function (expectedSignature) {
    if (!this.reader.readAndCheckSignature(expectedSignature)) {
        this.reader.index -= 4;
        var signature = this.reader.readString(4);
        throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty
(expectedSignature) + ")");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Read the local files, based on the offset read in the central part.
 */
readLocalFiles: function() {
    var i, file;
    for (i = 0; i &lt; this.files.length; i++) {
        file = this.files[i];
        this.reader.setIndex(file.localHeaderOffset);
        this.<span class="apidocCodeKeywordSpan">checkSignature</span>(sig.LOCAL_FILE_HEADER);
        file.readLocalPart(this.reader);
        file.handleUTF8();
        file.processAttributes();
    }
},
/**
 * Read the central directory.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.isSignature" id="apidoc.element.jszip.zipEntries.prototype.isSignature">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>isSignature
        <span class="apidocSignatureSpan">(askedIndex, expectedSignature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSignature = function (askedIndex, expectedSignature) {
    var currentIndex = this.reader.index;
    this.reader.setIndex(askedIndex);
    var signature = this.reader.readString(4);
    var result = signature === expectedSignature;
    this.reader.setIndex(currentIndex);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset &lt; 0) {
// Check if the content is a truncated zip or complete garbage.
// A "LOCAL_FILE_HEADER" is not required at the beginning (auto
// extractible zip for example) but it can give a good hint.
// If an ajax request was used without responseType, we will also
// get unreadable data.
var isGarbage = !this.<span class="apidocCodeKeywordSpan">isSignature</span>(0, sig.LOCAL_FILE_HEADER);

if (isGarbage) {
    throw new Error("Can't find end of central directory : is this a zip file ? " +
                    "If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html");
} else {
    throw new Error("Corrupted zip : can't find end of central directory");
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.load" id="apidoc.element.jszip.zipEntries.prototype.load">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>load
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (data) {
    this.prepareReader(data);
    this.readEndOfCentral();
    this.readCentralDir();
    this.readLocalFiles();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (nodejsUtils.isNode &amp;&amp; nodejsUtils.isStream(data)) {
    return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
}

return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
.then(function(data) {
    var zipEntries = new ZipEntries(options);
    zipEntries.<span class="apidocCodeKeywordSpan">load</span>(data);
    return zipEntries;
}).then(function checkCRC32(zipEntries) {
    var promises = [external.Promise.resolve(zipEntries)];
    var files = zipEntries.files;
    if (options.checkCRC32) {
        for (var i = 0; i &lt; files.length; i++) {
            promises.push(checkEntryCRC32(files[i]));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.prepareReader" id="apidoc.element.jszip.zipEntries.prototype.prepareReader">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>prepareReader
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareReader = function (data) {
    this.reader = readerFor(data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.reader = readerFor(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.<span class="apidocCodeKeywordSpan">prepareReader</span>(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.readBlockEndOfCentral" id="apidoc.element.jszip.zipEntries.prototype.readBlockEndOfCentral">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readBlockEndOfCentral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBlockEndOfCentral = function () {
    this.diskNumber = this.reader.readInt(2);
    this.diskWithCentralDirStart = this.reader.readInt(2);
    this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
    this.centralDirRecords = this.reader.readInt(2);
    this.centralDirSize = this.reader.readInt(4);
    this.centralDirOffset = this.reader.readInt(4);

    this.zipCommentLength = this.reader.readInt(2);
    // warning : the encoding depends of the system locale
    // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
    // On a windows machine, this field is encoded with the localized windows code page.
    var zipComment = this.reader.readData(this.zipCommentLength);
    var decodeParamType = support.uint8array ? "uint8array" : "array";
    // To get consistent behavior with the generation part, we will assume that
    // this is utf8 encoded unless specified otherwise.
    var decodeContent = utils.transformTo(decodeParamType, zipComment);
    this.zipComment = this.loadOptions.decodeFileName(decodeContent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        throw new Error("Corrupted zip : can't find end of central directory");
    }

}
this.reader.setIndex(offset);
var endOfCentralDirOffset = offset;
this.checkSignature(sig.CENTRAL_DIRECTORY_END);
this.<span class="apidocCodeKeywordSpan">readBlockEndOfCentral</span>();


/* extract from the zip spec :
    4)  If one of the fields in the end of central directory
        record is too small to hold required data, the field
        should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
        ZIP64 format record should be created.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.readBlockZip64EndOfCentral" id="apidoc.element.jszip.zipEntries.prototype.readBlockZip64EndOfCentral">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readBlockZip64EndOfCentral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBlockZip64EndOfCentral = function () {
    this.zip64EndOfCentralSize = this.reader.readInt(8);
    this.reader.skip(4);
    // this.versionMadeBy = this.reader.readString(2);
    // this.versionNeeded = this.reader.readInt(2);
    this.diskNumber = this.reader.readInt(4);
    this.diskWithCentralDirStart = this.reader.readInt(4);
    this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
    this.centralDirRecords = this.reader.readInt(8);
    this.centralDirSize = this.reader.readInt(8);
    this.centralDirOffset = this.reader.readInt(8);

    this.zip64ExtensibleData = {};
    var extraDataSize = this.zip64EndOfCentralSize - 44,
        index = 0,
        extraFieldId,
        extraFieldLength,
        extraFieldValue;
    while (index &lt; extraDataSize) {
        extraFieldId = this.reader.readInt(2);
        extraFieldLength = this.reader.readInt(4);
        extraFieldValue = this.reader.readData(extraFieldLength);
        this.zip64ExtensibleData[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
        if (this.relativeOffsetEndOfZip64CentralDir &lt; 0) {
            throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
        }
    }
    this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
    this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
    this.<span class="apidocCodeKeywordSpan">readBlockZip64EndOfCentral</span>();
}

var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
if (this.zip64) {
    expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
    expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.readBlockZip64EndOfCentralLocator" id="apidoc.element.jszip.zipEntries.prototype.readBlockZip64EndOfCentralLocator">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readBlockZip64EndOfCentralLocator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBlockZip64EndOfCentralLocator = function () {
    this.diskWithZip64CentralDirStart = this.reader.readInt(4);
    this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
    this.disksCount = this.reader.readInt(4);
    if (this.disksCount &gt; 1) {
        throw new Error("Multi-volumes zip are not supported");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// should look for a zip64 EOCD locator
offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
if (offset &lt; 0) {
    throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
}
this.reader.setIndex(offset);
this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
this.<span class="apidocCodeKeywordSpan">readBlockZip64EndOfCentralLocator</span>();

// now the zip64 EOCD record
if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
    // console.warn("ZIP64 end of central directory not where expected.");
    this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
    if (this.relativeOffsetEndOfZip64CentralDir &lt; 0) {
        throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.readCentralDir" id="apidoc.element.jszip.zipEntries.prototype.readCentralDir">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readCentralDir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readCentralDir = function () {
    var file;

    this.reader.setIndex(this.centralDirOffset);
    while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
        file = new ZipEntry({
            zip64: this.zip64
        }, this.loadOptions);
        file.readCentralPart(this.reader);
        this.files.push(file);
    }

    if (this.centralDirRecords !== this.files.length) {
        if (this.centralDirRecords !== 0 &amp;&amp; this.files.length === 0) {
            // We expected some records but couldn't find ANY.
            // This is really suspicious, as if something went wrong.
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.
files.length);
        } else {
            // We found some records but not all.
            // Something is wrong but we got something for the user: no error here.
            // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.<span class="apidocCodeKeywordSpan">readCentralDir</span>();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils"
;:32,"./zipEntry":34}],34:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.readEndOfCentral" id="apidoc.element.jszip.zipEntries.prototype.readEndOfCentral">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readEndOfCentral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readEndOfCentral = function () {
    var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
    if (offset &lt; 0) {
        // Check if the content is a truncated zip or complete garbage.
        // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
        // extractible zip for example) but it can give a good hint.
        // If an ajax request was used without responseType, we will also
        // get unreadable data.
        var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

        if (isGarbage) {
            throw new Error("Can't find end of central directory : is this a zip file ? " +
                            "If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html");
        } else {
            throw new Error("Corrupted zip : can't find end of central directory");
        }

    }
    this.reader.setIndex(offset);
    var endOfCentralDirOffset = offset;
    this.checkSignature(sig.CENTRAL_DIRECTORY_END);
    this.readBlockEndOfCentral();


<span class="apidocCodeCommentSpan">    /* extract from the zip spec :
        4)  If one of the fields in the end of central directory
            record is too small to hold required data, the field
            should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
            ZIP64 format record should be created.
        5)  The end of central directory record and the
            Zip64 end of central directory locator record must
            reside on the same disk when splitting or spanning
            an archive.
     */
</span>    if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk
 === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS
 || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
        this.zip64 = true;

        /*
        Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
        the zip file can fit into a 32bits integer. This cannot be solved : Javascript represents
        all numbers as 64-bit double precision IEEE 754 floating point numbers.
        So, we have 53bits for integers and bitwise operations treat everything as 32bits.
        see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
        and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
        */

        // should look for a zip64 EOCD locator
        offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        if (offset &lt; 0) {
            throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
        }
        this.reader.setIndex(offset);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        this.readBlockZip64EndOfCentralLocator();

        // now the zip64 EOCD record
        if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
            // console.warn("ZIP64 end of central directory not where expected.");
            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            if (this.relativeOffsetEndOfZip64CentralDir &lt; 0) {
                throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
            }
        }
        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
        this.readBlockZip64EndOfCentral();
    }

    var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
    if (this.zip64) {
        expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
        expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
    }

    var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

    if (extraBytes &gt; 0) {
        // console.warn(extraBytes, "extra bytes at beginning or within zipfile"); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.prepareReader(data);
        this.<span class="apidocCodeKeywordSpan">readEndOfCentral</span>();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntries.prototype.readLocalFiles" id="apidoc.element.jszip.zipEntries.prototype.readLocalFiles">
        function <span class="apidocSignatureSpan">jszip.zipEntries.prototype.</span>readLocalFiles
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readLocalFiles = function () {
    var i, file;
    for (i = 0; i &lt; this.files.length; i++) {
        file = this.files[i];
        this.reader.setIndex(file.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file.readLocalPart(this.reader);
        file.handleUTF8();
        file.processAttributes();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.<span class="apidocCodeKeywordSpan">readLocalFiles</span>();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils"
;:32,"./zipEntry":34}],34:[function(require,module,exports){
'use strict';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.zipEntry" id="apidoc.module.jszip.zipEntry">module jszip.zipEntry</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.zipEntry.zipEntry" id="apidoc.element.jszip.zipEntry.zipEntry">
        function <span class="apidocSignatureSpan">jszip.</span>zipEntry
        <span class="apidocSignatureSpan">(options, loadOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.zipEntry.prototype" id="apidoc.module.jszip.zipEntry.prototype">module jszip.zipEntry.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.findExtraFieldUnicodeComment" id="apidoc.element.jszip.zipEntry.prototype.findExtraFieldUnicodeComment">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>findExtraFieldUnicodeComment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findExtraFieldUnicodeComment = function () {
    var ucommentField = this.extraFields[0x6375];
    if (ucommentField) {
        var extraReader = readerFor(ucommentField.value);

        // wrong version
        if (extraReader.readInt(1) !== 1) {
            return null;
        }

        // the crc of the comment changed, this field is out of date.
        if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
            return null;
        }

        return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.fileNameStr = upath;
} else {
    // ASCII text or unsupported code page
    var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
    this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
}

var ucomment = this.<span class="apidocCodeKeywordSpan">findExtraFieldUnicodeComment</span>();
if (ucomment !== null) {
    this.fileCommentStr = ucomment;
} else {
    // ASCII text or unsupported code page
    var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);
    this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.findExtraFieldUnicodePath" id="apidoc.element.jszip.zipEntry.prototype.findExtraFieldUnicodePath">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>findExtraFieldUnicodePath
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findExtraFieldUnicodePath = function () {
    var upathField = this.extraFields[0x7075];
    if (upathField) {
        var extraReader = readerFor(upathField.value);

        // wrong version
        if (extraReader.readInt(1) !== 1) {
            return null;
        }

        // the crc of the filename changed, this field is out of date.
        if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
            return null;
        }

        return utf8.utf8decode(extraReader.readData(upathField.length - 5));
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
handleUTF8: function() {
    var decodeParamType = support.uint8array ? "uint8array" : "array";
    if (this.useUTF8()) {
        this.fileNameStr = utf8.utf8decode(this.fileName);
        this.fileCommentStr = utf8.utf8decode(this.fileComment);
    } else {
        var upath = this.<span class="apidocCodeKeywordSpan">findExtraFieldUnicodePath</span>();
        if (upath !== null) {
            this.fileNameStr = upath;
        } else {
            // ASCII text or unsupported code page
            var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.handleUTF8" id="apidoc.element.jszip.zipEntry.prototype.handleUTF8">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>handleUTF8
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleUTF8 = function () {
    var decodeParamType = support.uint8array ? "uint8array" : "array";
    if (this.useUTF8()) {
        this.fileNameStr = utf8.utf8decode(this.fileName);
        this.fileCommentStr = utf8.utf8decode(this.fileComment);
    } else {
        var upath = this.findExtraFieldUnicodePath();
        if (upath !== null) {
            this.fileNameStr = upath;
        } else {
            // ASCII text or unsupported code page
            var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
        }

        var ucomment = this.findExtraFieldUnicodeComment();
        if (ucomment !== null) {
            this.fileCommentStr = ucomment;
        } else {
            // ASCII text or unsupported code page
            var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
readLocalFiles: function() {
    var i, file;
    for (i = 0; i &lt; this.files.length; i++) {
        file = this.files[i];
        this.reader.setIndex(file.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file.readLocalPart(this.reader);
        file.<span class="apidocCodeKeywordSpan">handleUTF8</span>();
        file.processAttributes();
    }
},
/**
 * Read the central directory.
 */
readCentralDir: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.isEncrypted" id="apidoc.element.jszip.zipEntry.prototype.isEncrypted">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>isEncrypted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEncrypted = function () {
    // bit 1 is set
    return (this.bitFlag &amp; 0x0001) === 0x0001;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.extraFieldsLength = reader.readInt(2);
this.fileCommentLength = reader.readInt(2);
this.diskNumberStart = reader.readInt(2);
this.internalFileAttributes = reader.readInt(2);
this.externalFileAttributes = reader.readInt(4);
this.localHeaderOffset = reader.readInt(4);

if (this.<span class="apidocCodeKeywordSpan">isEncrypted</span>()) {
    throw new Error("Encrypted zip are not supported");
}

// will be read in the local part, see the comments there
reader.skip(fileNameLength);
this.readExtraFields(reader);
this.parseZIP64ExtraField(reader);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.parseZIP64ExtraField" id="apidoc.element.jszip.zipEntry.prototype.parseZIP64ExtraField">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>parseZIP64ExtraField
        <span class="apidocSignatureSpan">(reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseZIP64ExtraField = function (reader) {

    if (!this.extraFields[0x0001]) {
        return;
    }

    // should be something, preparing the extra reader
    var extraReader = readerFor(this.extraFields[0x0001].value);

    // I really hope that these 64bits integer can fit in 32 bits integer, because js
    // won't let us have more.
    if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
        this.uncompressedSize = extraReader.readInt(8);
    }
    if (this.compressedSize === utils.MAX_VALUE_32BITS) {
        this.compressedSize = extraReader.readInt(8);
    }
    if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
        this.localHeaderOffset = extraReader.readInt(8);
    }
    if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
        this.diskNumberStart = extraReader.readInt(4);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this.isEncrypted()) {
        throw new Error("Encrypted zip are not supported");
    }

    // will be read in the local part, see the comments there
    reader.skip(fileNameLength);
    this.readExtraFields(reader);
    this.<span class="apidocCodeKeywordSpan">parseZIP64ExtraField</span>(reader);
    this.fileComment = reader.readData(this.fileCommentLength);
},

/**
 * Parse the external file attributes and get the unix/dos permissions.
 */
processAttributes: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.processAttributes" id="apidoc.element.jszip.zipEntry.prototype.processAttributes">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>processAttributes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processAttributes = function () {
    this.unixPermissions = null;
    this.dosPermissions = null;
    var madeBy = this.versionMadeBy &gt;&gt; 8;

    // Check if we have the DOS directory flag set.
    // We look for it in the DOS and UNIX permissions
    // but some unknown platform could set it as a compatibility flag.
    this.dir = this.externalFileAttributes &amp; 0x0010 ? true : false;

    if(madeBy === MADE_BY_DOS) {
        // first 6 bits (0 to 5)
        this.dosPermissions = this.externalFileAttributes &amp; 0x3F;
    }

    if(madeBy === MADE_BY_UNIX) {
        this.unixPermissions = (this.externalFileAttributes &gt;&gt; 16) &amp; 0xFFFF;
        // the octal permissions are in (this.unixPermissions &amp; 0x01FF).toString(8);
    }

    // fail safe : if the name ends with a / it probably means a folder
    if (!this.dir &amp;&amp; this.fileNameStr.slice(-1) === '/') {
        this.dir = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var i, file;
    for (i = 0; i &lt; this.files.length; i++) {
        file = this.files[i];
        this.reader.setIndex(file.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file.readLocalPart(this.reader);
        file.handleUTF8();
        file.<span class="apidocCodeKeywordSpan">processAttributes</span>();
    }
},
/**
 * Read the central directory.
 */
readCentralDir: function() {
    var file;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.readCentralPart" id="apidoc.element.jszip.zipEntry.prototype.readCentralPart">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>readCentralPart
        <span class="apidocSignatureSpan">(reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readCentralPart = function (reader) {
    this.versionMadeBy = reader.readInt(2);
    reader.skip(2);
    // this.versionNeeded = reader.readInt(2);
    this.bitFlag = reader.readInt(2);
    this.compressionMethod = reader.readString(2);
    this.date = reader.readDate();
    this.crc32 = reader.readInt(4);
    this.compressedSize = reader.readInt(4);
    this.uncompressedSize = reader.readInt(4);
    var fileNameLength = reader.readInt(2);
    this.extraFieldsLength = reader.readInt(2);
    this.fileCommentLength = reader.readInt(2);
    this.diskNumberStart = reader.readInt(2);
    this.internalFileAttributes = reader.readInt(2);
    this.externalFileAttributes = reader.readInt(4);
    this.localHeaderOffset = reader.readInt(4);

    if (this.isEncrypted()) {
        throw new Error("Encrypted zip are not supported");
    }

    // will be read in the local part, see the comments there
    reader.skip(fileNameLength);
    this.readExtraFields(reader);
    this.parseZIP64ExtraField(reader);
    this.fileComment = reader.readData(this.fileCommentLength);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var file;

this.reader.setIndex(this.centralDirOffset);
while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
    file = new ZipEntry({
        zip64: this.zip64
    }, this.loadOptions);
    file.<span class="apidocCodeKeywordSpan">readCentralPart</span>(this.reader);
    this.files.push(file);
}

if (this.centralDirRecords !== this.files.length) {
    if (this.centralDirRecords !== 0 &amp;&amp; this.files.length === 0) {
        // We expected some records but couldn't find ANY.
        // This is really suspicious, as if something went wrong.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.readExtraFields" id="apidoc.element.jszip.zipEntry.prototype.readExtraFields">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>readExtraFields
        <span class="apidocSignatureSpan">(reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readExtraFields = function (reader) {
    var end = reader.index + this.extraFieldsLength,
        extraFieldId,
        extraFieldLength,
        extraFieldValue;

    if (!this.extraFields) {
        this.extraFields = {};
    }

    while (reader.index &lt; end) {
        extraFieldId = reader.readInt(2);
        extraFieldLength = reader.readInt(2);
        extraFieldValue = reader.readData(extraFieldLength);

        this.extraFields[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (this.isEncrypted()) {
        throw new Error("Encrypted zip are not supported");
    }

    // will be read in the local part, see the comments there
    reader.skip(fileNameLength);
    this.<span class="apidocCodeKeywordSpan">readExtraFields</span>(reader);
    this.parseZIP64ExtraField(reader);
    this.fileComment = reader.readData(this.fileCommentLength);
},

/**
 * Parse the external file attributes and get the unix/dos permissions.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.readLocalPart" id="apidoc.element.jszip.zipEntry.prototype.readLocalPart">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>readLocalPart
        <span class="apidocSignatureSpan">(reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readLocalPart = function (reader) {
    var compression, localExtraFieldsLength;

    // we already know everything from the central dir !
    // If the central dir data are false, we are doomed.
    // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
    // The less data we get here, the more reliable this should be.
    // Let's skip the whole header and dash to the data !
    reader.skip(22);
    // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
    // Strangely, the filename here is OK.
    // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
    // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
    // Search "unzip mismatching "local" filename continuing with "central" filename version" on
    // the internet.
    //
    // I think I see the logic here : the central directory is used to display
    // content and the local directory is used to extract the files. Mixing / and \
    // may be used to display \ to windows users and use / when extracting the files.
    // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
    this.fileNameLength = reader.readInt(2);
    localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
    // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
    this.fileName = reader.readData(this.fileNameLength);
    reader.skip(localExtraFieldsLength);

    if (this.compressedSize === -1 || this.uncompressedSize === -1) {
        throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -
1 || uncompressedSize === -1)");
    }

    compression = findCompression(this.compressionMethod);
    if (compression === null) { // no compression found
        throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils
.transformTo("string", this.fileName) + ")");
    }
    this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData
(this.compressedSize));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
readLocalFiles: function() {
    var i, file;
    for (i = 0; i &lt; this.files.length; i++) {
        file = this.files[i];
        this.reader.setIndex(file.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file.<span class="apidocCodeKeywordSpan">readLocalPart</span>(this.reader);
        file.handleUTF8();
        file.processAttributes();
    }
},
/**
 * Read the central directory.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipEntry.prototype.useUTF8" id="apidoc.element.jszip.zipEntry.prototype.useUTF8">
        function <span class="apidocSignatureSpan">jszip.zipEntry.prototype.</span>useUTF8
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">useUTF8 = function () {
    // bit 11 is set
    return (this.bitFlag &amp; 0x0800) === 0x0800;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
},
/**
 * Apply an UTF8 transformation if needed.
 */
handleUTF8: function() {
    var decodeParamType = support.uint8array ? "uint8array" : "array";
    if (this.<span class="apidocCodeKeywordSpan">useUTF8</span>()) {
        this.fileNameStr = utf8.utf8decode(this.fileName);
        this.fileCommentStr = utf8.utf8decode(this.fileComment);
    } else {
        var upath = this.findExtraFieldUnicodePath();
        if (upath !== null) {
            this.fileNameStr = upath;
        } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.zipObject" id="apidoc.module.jszip.zipObject">module jszip.zipObject</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.zipObject.zipObject" id="apidoc.element.jszip.zipObject.zipObject">
        function <span class="apidocSignatureSpan">jszip.</span>zipObject
        <span class="apidocSignatureSpan">(name, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zipObject = function (name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression : options.compression,
        compressionOptions : options.compressionOptions
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jszip.zipObject.prototype" id="apidoc.module.jszip.zipObject.prototype">module jszip.zipObject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype._compressWorker" id="apidoc.element.jszip.zipObject.prototype._compressWorker">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>_compressWorker
        <span class="apidocSignatureSpan">(compression, compressionOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compressWorker = function (compression, compressionOptions) {
    if (
        this._data instanceof CompressedObject &amp;&amp;
        this._data.compression.magic === compression.magic
    ) {
        return this._data.getCompressedWorker();
    } else {
        var result = this._decompressWorker();
        if(!this._dataBinary) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
        }
        return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        zip.forEach(function (relativePath, file) {
entriesCount++;
var compression = getCompression(file.options.compression, options.compression);
var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
var dir = file.dir, date = file.date;

file.<span class="apidocCodeKeywordSpan">_compressWorker</span>(compression, compressionOptions)
.withStreamInfo("file", {
    name : relativePath,
    dir : dir,
    date : date,
    comment : file.comment || "",
    unixPermissions : file.unixPermissions,
    dosPermissions : file.dosPermissions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype._decompressWorker" id="apidoc.element.jszip.zipObject.prototype._decompressWorker">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>_decompressWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_decompressWorker = function () {
    if (this._data instanceof CompressedObject) {
        return this._data.getContentWorker();
    } else if (this._data instanceof GenericWorker) {
        return this._data;
    } else {
        return new DataWorker(this._data);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     */
    internalStream: function (type) {
var outputType = type.toLowerCase();
var askUnicodeString = outputType === "string" || outputType === "text";
if (outputType === "binarystring" || outputType === "text") {
    outputType = "string";
}
var result = this.<span class="apidocCodeKeywordSpan">_decompressWorker</span>();

var isUnicodeString = !this._dataBinary;

if (isUnicodeString &amp;&amp; !askUnicodeString) {
    result = result.pipe(new utf8.Utf8EncodeWorker());
}
if (!isUnicodeString &amp;&amp; askUnicodeString) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.asArrayBuffer" id="apidoc.element.jszip.zipObject.prototype.asArrayBuffer">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asArrayBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asArrayBuffer = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.asBinary" id="apidoc.element.jszip.zipObject.prototype.asBinary">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asBinary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asBinary = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.asNodeBuffer" id="apidoc.element.jszip.zipObject.prototype.asNodeBuffer">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asNodeBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asNodeBuffer = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.asText" id="apidoc.element.jszip.zipObject.prototype.asText">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asText = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.asUint8Array" id="apidoc.element.jszip.zipObject.prototype.asUint8Array">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>asUint8Array
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asUint8Array = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.async" id="apidoc.element.jszip.zipObject.prototype.async">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>async
        <span class="apidocSignatureSpan">(type, onUpdate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">async = function (type, onUpdate) {
    return this.internalStream(type).accumulate(onUpdate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.internalStream" id="apidoc.element.jszip.zipObject.prototype.internalStream">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>internalStream
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">internalStream = function (type) {
    var outputType = type.toLowerCase();
    var askUnicodeString = outputType === "string" || outputType === "text";
    if (outputType === "binarystring" || outputType === "text") {
        outputType = "string";
    }
    var result = this._decompressWorker();

    var isUnicodeString = !this._dataBinary;

    if (isUnicodeString &amp;&amp; !askUnicodeString) {
        result = result.pipe(new utf8.Utf8EncodeWorker());
    }
    if (!isUnicodeString &amp;&amp; askUnicodeString) {
        result = result.pipe(new utf8.Utf8DecodeWorker());
    }

    return new StreamHelper(result, outputType, "");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Prepare the content in the asked type.
 * @param {String} type the type of the result.
 * @param {Function} onUpdate a function to call on each internal update.
 * @return Promise the promise of the result.
 */
async: function (type, onUpdate) {
    return this.<span class="apidocCodeKeywordSpan">internalStream</span>(type).accumulate(onUpdate);
},

/**
 * Prepare the content as a nodejs stream.
 * @param {String} type the type of each chunk.
 * @param {Function} onUpdate a function to call on each internal update.
 * @return Stream the stream.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jszip.zipObject.prototype.nodeStream" id="apidoc.element.jszip.zipObject.prototype.nodeStream">
        function <span class="apidocSignatureSpan">jszip.zipObject.prototype.</span>nodeStream
        <span class="apidocSignatureSpan">(type, onUpdate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nodeStream = function (type, onUpdate) {
    return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>